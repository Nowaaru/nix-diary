From b7473ab406342766b6063a29ae1a2909f6a5a721 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Wed, 20 Oct 2021 18:47:46 +0200
Subject: [PATCH 01/14] render/timeline: introduce wlr_timeline

wlr_timeline is a synchronization primitive based on drm_syncobj
timelines. They are heavily inspired from Vulkan timeline
semaphores [1].

[1]: https://www.khronos.org/blog/vulkan-timeline-semaphores
---
 include/wlr/render/timeline.h |  64 +++++++++++++++++++++
 render/meson.build            |   1 +
 render/timeline.c             | 104 ++++++++++++++++++++++++++++++++++
 3 files changed, 169 insertions(+)
 create mode 100644 include/wlr/render/timeline.h
 create mode 100644 render/timeline.c

diff --git a/include/wlr/render/timeline.h b/include/wlr/render/timeline.h
new file mode 100644
index 0000000000..a286111fe3
--- /dev/null
+++ b/include/wlr/render/timeline.h
@@ -0,0 +1,64 @@
+#ifndef WLR_RENDER_TIMELINE_H
+#define WLR_RENDER_TIMELINE_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+/**
+ * A synchronization timeline.
+ *
+ * Timelines are used to synchronize accesses to buffers. Given a producer
+ * (writing contents to a buffer) and a consumer (reading from the buffer), the
+ * compositor needs to synchronize back-and-forth between these two users. The
+ * consumer needs to wait for the producer to signal that they're done with the
+ * writes, and the producer needs to wait for the consumer to signal that
+ * they're done with the reads.
+ *
+ * Timelines provide synchronization points in the form of monotonically
+ * increasing 64-bit integer values.
+ *
+ * wlroots timelines are designed after Vulkan timeline semaphores. For more
+ * information on the Vulkan APIs, see:
+ * https://www.khronos.org/blog/vulkan-timeline-semaphores
+ *
+ * wlroots timelines are powered by DRM synchronization objects (drm_syncobj):
+ * https://dri.freedesktop.org/docs/drm/gpu/drm-mm.html#drm-sync-objects
+ */
+struct wlr_render_timeline;
+
+/**
+ * Create a new synchronization timeline.
+ */
+struct wlr_render_timeline *wlr_render_timeline_create(int drm_fd);
+/**
+ * Reference a synchronization timeline.
+ */
+struct wlr_render_timeline *wlr_render_timeline_ref(struct wlr_render_timeline *timeline);
+/**
+ * Unreference a synchronization timeline.
+ */
+void wlr_render_timeline_unref(struct wlr_render_timeline *timeline);
+/**
+ * Export a timeline point as a sync_file FD.
+ *
+ * The returned sync_file will be signalled when the provided point is
+ * signalled on the timeline.
+ *
+ * This allows inter-operation with other APIs which don't support drm_syncobj
+ * yet. The synchronization point needs to have already materialized:
+ * wait-before-signal is not supported.
+ */
+int wlr_render_timeline_export_sync_file(struct wlr_render_timeline *timeline,
+	uint64_t src_point);
+/**
+ * Import a timeline point from a sync_file FD.
+ *
+ * The provided timeline point will be signalled when the provided sync_file is.
+ *
+ * This allows inter-operation with other APIs which don't support drm_syncobj
+ * yet.
+ */
+bool wlr_render_timeline_import_sync_file(struct wlr_render_timeline *timeline,
+	uint64_t dst_point, int sync_file_fd);
+
+#endif
diff --git a/render/meson.build b/render/meson.build
index f09905c716..b4f1bc26dc 100644
--- a/render/meson.build
+++ b/render/meson.build
@@ -11,6 +11,7 @@ wlr_files += files(
 	'pass.c',
 	'pixel_format.c',
 	'swapchain.c',
+	'timeline.c',
 	'wlr_renderer.c',
 	'wlr_texture.c',
 )
diff --git a/render/timeline.c b/render/timeline.c
new file mode 100644
index 0000000000..ec8c82bf7d
--- /dev/null
+++ b/render/timeline.c
@@ -0,0 +1,104 @@
+#include <assert.h>
+#include <xf86drm.h>
+#include <stdlib.h>
+#include <wlr/render/timeline.h>
+#include <wlr/util/log.h>
+
+struct wlr_render_timeline {
+	int drm_fd;
+	uint32_t handle;
+	size_t n_refs;
+};
+
+struct wlr_render_timeline *wlr_render_timeline_create(int drm_fd) {
+	struct wlr_render_timeline *timeline = calloc(1, sizeof(*timeline));
+	if (timeline == NULL) {
+		return NULL;
+	}
+	timeline->drm_fd = drm_fd;
+	timeline->n_refs = 1;
+
+	if (drmSyncobjCreate(drm_fd, 0, &timeline->handle) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjCreate failed");
+		free(timeline);
+		return NULL;
+	}
+
+	return timeline;
+}
+
+struct wlr_render_timeline *wlr_render_timeline_ref(struct wlr_render_timeline *timeline) {
+	timeline->n_refs++;
+	return timeline;
+}
+
+void wlr_render_timeline_unref(struct wlr_render_timeline *timeline) {
+	if (timeline == NULL) {
+		return;
+	}
+
+	assert(timeline->n_refs > 0);
+	timeline->n_refs--;
+	if (timeline->n_refs == 0) {
+		return;
+	}
+
+	drmSyncobjDestroy(timeline->drm_fd, timeline->handle);
+	free(timeline);
+}
+
+int wlr_render_timeline_export_sync_file(struct wlr_render_timeline *timeline,
+		uint64_t src_point) {
+	int sync_file_fd = -1;
+
+	uint32_t syncobj_handle;
+	if (drmSyncobjCreate(timeline->drm_fd, 0, &syncobj_handle) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjCreate failed");
+		return -1;
+	}
+
+	if (drmSyncobjTransfer(timeline->drm_fd, syncobj_handle, 0,
+			timeline->handle, src_point, 0) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjTransfer failed");
+		goto out;
+	}
+
+	if (drmSyncobjExportSyncFile(timeline->drm_fd,
+			syncobj_handle, &sync_file_fd) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjExportSyncFile failed");
+		goto out;
+	}
+
+out:
+	drmSyncobjDestroy(timeline->drm_fd, syncobj_handle);
+	return sync_file_fd;
+}
+
+bool wlr_render_timeline_import_sync_file(struct wlr_render_timeline *timeline,
+		uint64_t dst_point, int sync_file_fd) {
+	bool ok = false;
+
+	uint32_t syncobj_handle;
+	if (drmSyncobjCreate(timeline->drm_fd, 0, &syncobj_handle) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjCreate failed");
+		return -1;
+	}
+
+	if (drmSyncobjImportSyncFile(timeline->drm_fd, syncobj_handle,
+			sync_file_fd) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjImportSyncFile failed");
+		goto out;
+	}
+
+	if (drmSyncobjTransfer(timeline->drm_fd, timeline->handle, dst_point,
+			syncobj_handle, 0, 0) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjTransfer failed");
+		goto out;
+	}
+
+	ok = true;
+
+out:
+	drmSyncobjDestroy(timeline->drm_fd, syncobj_handle);
+	return ok;
+}
-- 
GitLab


From 3a43b60c9734c2d5bbbc51c40d2df90f61d5008f Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Mon, 10 Jul 2023 10:53:12 +0200
Subject: [PATCH 02/14] render: add explicit sync API

---
 include/wlr/render/pass.h | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/include/wlr/render/pass.h b/include/wlr/render/pass.h
index d1b3eb1505..9b1b3d7bb5 100644
--- a/include/wlr/render/pass.h
+++ b/include/wlr/render/pass.h
@@ -30,6 +30,15 @@ struct wlr_render_timer;
 struct wlr_buffer_pass_options {
 	/* Timer to measure the duration of the render pass */
 	struct wlr_render_timer *timer;
+
+	/* Signal a timeline synchronization point when the render pass completes.
+	 *
+	 * When a compositor provides a signal timeline, the renderer may skip
+	 * implicit signal synchronization. Compositors are not allowed to mix
+	 * implicit and explicit signal synchronization usage.
+	 */
+	struct wlr_render_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 /**
@@ -85,6 +94,15 @@ struct wlr_render_texture_options {
 	enum wlr_scale_filter_mode filter_mode;
 	/* Blend mode */
 	enum wlr_render_blend_mode blend_mode;
+
+	/* Wait for a timeline synchronization point before texturing.
+	 *
+	 * When a compositor calls wlr_renderer_wait_timeline(), the renderer may
+	 * skip implicit wait synchronization. Compositors are not allowed to mix
+	 * implicit and explicit wait synchronization usage.
+	 */
+	struct wlr_render_timeline *wait_timeline;
+	uint64_t wait_point;
 };
 
 /**
-- 
GitLab


From 923711d6b306ab113603a9f864d17e7652f719b2 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Mon, 16 Mar 2020 17:24:25 +0100
Subject: [PATCH 03/14] render/egl: add support for explicit sync extensions

---
 include/render/egl.h | 12 +++++++
 render/egl.c         | 74 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 86 insertions(+)

diff --git a/include/render/egl.h b/include/render/egl.h
index e8b85964a5..c696725051 100644
--- a/include/render/egl.h
+++ b/include/render/egl.h
@@ -38,6 +38,10 @@ struct wlr_egl {
 		PFNEGLQUERYDISPLAYATTRIBEXTPROC eglQueryDisplayAttribEXT;
 		PFNEGLQUERYDEVICESTRINGEXTPROC eglQueryDeviceStringEXT;
 		PFNEGLQUERYDEVICESEXTPROC eglQueryDevicesEXT;
+		PFNEGLCREATESYNCKHRPROC eglCreateSyncKHR;
+		PFNEGLDESTROYSYNCKHRPROC eglDestroySyncKHR;
+		PFNEGLDUPNATIVEFENCEFDANDROIDPROC eglDupNativeFenceFDANDROID;
+		PFNEGLWAITSYNCKHRPROC eglWaitSyncKHR;
 	} procs;
 
 	bool has_modifiers;
@@ -114,4 +118,12 @@ bool wlr_egl_unset_current(struct wlr_egl *egl);
 
 bool wlr_egl_is_current(struct wlr_egl *egl);
 
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd);
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync);
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync);
+
 #endif
diff --git a/render/egl.c b/render/egl.c
index ac991295ed..a370c05b71 100644
--- a/render/egl.c
+++ b/render/egl.c
@@ -348,6 +348,18 @@ static bool egl_init_display(struct wlr_egl *egl, EGLDisplay display) {
 		return false;
 	}
 
+	if (check_egl_ext(display_exts_str, "EGL_KHR_fence_sync") &&
+			check_egl_ext(display_exts_str, "EGL_ANDROID_native_fence_sync")) {
+		load_egl_proc(&egl->procs.eglCreateSyncKHR, "eglCreateSyncKHR");
+		load_egl_proc(&egl->procs.eglDestroySyncKHR, "eglDestroySyncKHR");
+		load_egl_proc(&egl->procs.eglDupNativeFenceFDANDROID,
+			"eglDupNativeFenceFDANDROID");
+	}
+
+	if (check_egl_ext(display_exts_str, "EGL_KHR_wait_sync")) {
+		load_egl_proc(&egl->procs.eglWaitSyncKHR, "eglWaitSyncKHR");
+	}
+
 	egl->exts.IMG_context_priority =
 		check_egl_ext(display_exts_str, "EGL_IMG_context_priority");
 
@@ -1018,3 +1030,65 @@ int wlr_egl_dup_drm_fd(struct wlr_egl *egl) {
 	}
 	return fd;
 }
+
+EGLSyncKHR wlr_egl_create_sync(struct wlr_egl *egl, int fence_fd) {
+	if (!egl->procs.eglCreateSyncKHR) {
+		return EGL_NO_SYNC_KHR;
+	}
+
+	EGLint attribs[3] = { EGL_NONE };
+	int dup_fd = -1;
+	if (fence_fd >= 0) {
+		dup_fd = fcntl(fence_fd, F_DUPFD_CLOEXEC, 0);
+		if (dup_fd < 0) {
+			wlr_log_errno(WLR_ERROR, "dup failed");
+			return EGL_NO_SYNC_KHR;
+		}
+
+		attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+		attribs[1] = dup_fd;
+		attribs[2] = EGL_NONE;
+	}
+
+	EGLSyncKHR sync = egl->procs.eglCreateSyncKHR(egl->display,
+		EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
+	if (sync == EGL_NO_SYNC_KHR) {
+		wlr_log(WLR_ERROR, "eglCreateSyncKHR failed");
+		if (dup_fd >= 0) {
+			close(dup_fd);
+		}
+	}
+	return sync;
+}
+
+void wlr_egl_destroy_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (sync == EGL_NO_SYNC_KHR) {
+		return;
+	}
+	assert(egl->procs.eglDestroySyncKHR);
+	if (egl->procs.eglDestroySyncKHR(egl->display, sync) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglDestroySyncKHR failed");
+	}
+}
+
+int wlr_egl_dup_fence_fd(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (!egl->procs.eglDupNativeFenceFDANDROID) {
+		return -1;
+	}
+
+	int fd = egl->procs.eglDupNativeFenceFDANDROID(egl->display, sync);
+	if (fd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
+		wlr_log(WLR_ERROR, "eglDupNativeFenceFDANDROID failed");
+		return -1;
+	}
+
+	return fd;
+}
+
+bool wlr_egl_wait_sync(struct wlr_egl *egl, EGLSyncKHR sync) {
+	if (egl->procs.eglWaitSyncKHR(egl->display, sync, 0) != EGL_TRUE) {
+		wlr_log(WLR_ERROR, "eglWaitSyncKHR failed");
+		return false;
+	}
+	return true;
+}
-- 
GitLab


From bd81d5a39f185b110e4cf34d4692cbbab16cdab8 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Mon, 10 Jul 2023 16:15:59 +0200
Subject: [PATCH 04/14] render/gles2: implement explicit sync API

---
 include/render/gles2.h  |  5 +++-
 render/gles2/pass.c     | 58 ++++++++++++++++++++++++++++++++++++++---
 render/gles2/renderer.c |  3 ++-
 3 files changed, 61 insertions(+), 5 deletions(-)

diff --git a/include/render/gles2.h b/include/render/gles2.h
index db301c6e4e..1a2617b0ec 100644
--- a/include/render/gles2.h
+++ b/include/render/gles2.h
@@ -136,6 +136,8 @@ struct wlr_gles2_render_pass {
 	float projection_matrix[9];
 	struct wlr_egl_context prev_ctx;
 	struct wlr_gles2_render_timer *timer;
+	struct wlr_render_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 bool is_gles2_pixel_format_supported(const struct wlr_gles2_renderer *renderer,
@@ -167,6 +169,7 @@ void push_gles2_debug_(struct wlr_gles2_renderer *renderer,
 void pop_gles2_debug(struct wlr_gles2_renderer *renderer);
 
 struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *buffer,
-	struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer);
+	struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer,
+	struct wlr_render_timeline *signal_timeline, uint64_t signal_point);
 
 #endif
diff --git a/render/gles2/pass.c b/render/gles2/pass.c
index 9177b0a1fa..6bbaee2923 100644
--- a/render/gles2/pass.c
+++ b/render/gles2/pass.c
@@ -2,8 +2,11 @@
 #include <assert.h>
 #include <pixman.h>
 #include <time.h>
+#include <unistd.h>
+#include <wlr/render/timeline.h>
 #include <wlr/types/wlr_matrix.h>
 #include <wlr/util/transform.h>
+#include "render/egl.h"
 #include "render/gles2.h"
 #include "types/wlr_matrix.h"
 
@@ -21,6 +24,7 @@ static bool render_pass_submit(struct wlr_render_pass *wlr_pass) {
 	struct wlr_gles2_render_pass *pass = get_render_pass(wlr_pass);
 	struct wlr_gles2_renderer *renderer = pass->buffer->renderer;
 	struct wlr_gles2_render_timer *timer = pass->timer;
+	bool ok = false;
 
 	push_gles2_debug(renderer);
 
@@ -36,16 +40,40 @@ static bool render_pass_submit(struct wlr_render_pass *wlr_pass) {
 		clock_gettime(CLOCK_MONOTONIC, &timer->cpu_end);
 	}
 
-	glFlush();
+	if (pass->signal_timeline != NULL) {
+		EGLSyncKHR sync = wlr_egl_create_sync(renderer->egl, -1);
+		if (sync == EGL_NO_SYNC_KHR) {
+			goto out;
+		}
+
+		int sync_file_fd = wlr_egl_dup_fence_fd(renderer->egl, sync);
+		wlr_egl_destroy_sync(renderer->egl, sync);
+		if (sync_file_fd < 0) {
+			goto out;
+		}
+
+		bool ok = wlr_render_timeline_import_sync_file(pass->signal_timeline, pass->signal_point, sync_file_fd);
+		close(sync_file_fd);
+		if (!ok) {
+			goto out;
+		}
+	} else {
+		glFlush();
+	}
+
+	ok = true;
+
+out:
 	glBindFramebuffer(GL_FRAMEBUFFER, 0);
 
 	pop_gles2_debug(renderer);
 	wlr_egl_restore_context(&pass->prev_ctx);
 
+	wlr_render_timeline_unref(pass->signal_timeline);
 	wlr_buffer_unlock(pass->buffer->buffer);
 	free(pass);
 
-	return true;
+	return ok;
 }
 
 static void render(const struct wlr_box *box, const pixman_region32_t *clip, GLint attrib) {
@@ -175,6 +203,27 @@ static void render_pass_add_texture(struct wlr_render_pass *wlr_pass,
 	src_fbox.height /= options->texture->height;
 
 	push_gles2_debug(renderer);
+
+	if (options->wait_timeline != NULL) {
+		int sync_file_fd =
+			wlr_render_timeline_export_sync_file(options->wait_timeline, options->wait_point);
+		if (sync_file_fd < 0) {
+			return;
+		}
+
+		EGLSyncKHR sync = wlr_egl_create_sync(renderer->egl, sync_file_fd);
+		close(sync_file_fd);
+		if (sync == EGL_NO_SYNC_KHR) {
+			return;
+		}
+
+		bool ok = wlr_egl_wait_sync(renderer->egl, sync);
+		wlr_egl_destroy_sync(renderer->egl, sync);
+		if (!ok) {
+			return;
+		}
+	}
+
 	setup_blending(!texture->has_alpha && alpha == 1.0 ?
 		WLR_RENDER_BLEND_MODE_NONE : options->blend_mode);
 
@@ -247,7 +296,8 @@ static const char *reset_status_str(GLenum status) {
 }
 
 struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *buffer,
-		struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer) {
+		struct wlr_egl_context *prev_ctx, struct wlr_gles2_render_timer *timer,
+		struct wlr_render_timeline *signal_timeline, uint64_t signal_point) {
 	struct wlr_gles2_renderer *renderer = buffer->renderer;
 	struct wlr_buffer *wlr_buffer = buffer->buffer;
 
@@ -275,6 +325,8 @@ struct wlr_gles2_render_pass *begin_gles2_buffer_pass(struct wlr_gles2_buffer *b
 	pass->buffer = buffer;
 	pass->timer = timer;
 	pass->prev_ctx = *prev_ctx;
+	pass->signal_timeline = wlr_render_timeline_ref(signal_timeline);
+	pass->signal_point = signal_point;
 
 	matrix_projection(pass->projection_matrix, wlr_buffer->width, wlr_buffer->height,
 		WL_OUTPUT_TRANSFORM_FLIPPED_180);
diff --git a/render/gles2/renderer.c b/render/gles2/renderer.c
index e095f469c3..71c7ce2c86 100644
--- a/render/gles2/renderer.c
+++ b/render/gles2/renderer.c
@@ -263,7 +263,8 @@ static struct wlr_render_pass *gles2_begin_buffer_pass(struct wlr_renderer *wlr_
 		return NULL;
 	}
 
-	struct wlr_gles2_render_pass *pass = begin_gles2_buffer_pass(buffer, &prev_ctx, timer);
+	struct wlr_gles2_render_pass *pass = begin_gles2_buffer_pass(buffer,
+		&prev_ctx, timer, options->signal_timeline, options->signal_point);
 	if (!pass) {
 		return NULL;
 	}
-- 
GitLab


From 35b8cf97111a0462d95757cc7d217e9b813d691b Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Wed, 20 Oct 2021 19:29:00 +0200
Subject: [PATCH 05/14] output: add explicit sync API

---
 include/wlr/types/wlr_output.h | 34 ++++++++++++++++++++++++++++++++++
 types/output/output.c          | 16 +++++++++++++---
 types/output/state.c           | 14 ++++++++++++++
 3 files changed, 61 insertions(+), 3 deletions(-)

diff --git a/include/wlr/types/wlr_output.h b/include/wlr/types/wlr_output.h
index 865bc5e5cd..7e3b11ee6d 100644
--- a/include/wlr/types/wlr_output.h
+++ b/include/wlr/types/wlr_output.h
@@ -65,6 +65,8 @@ enum wlr_output_state_field {
 	WLR_OUTPUT_STATE_RENDER_FORMAT = 1 << 8,
 	WLR_OUTPUT_STATE_SUBPIXEL = 1 << 9,
 	WLR_OUTPUT_STATE_LAYERS = 1 << 10,
+	WLR_OUTPUT_STATE_WAIT_TIMELINE = 1 << 11,
+	WLR_OUTPUT_STATE_SIGNAL_TIMELINE = 1 << 12,
 };
 
 enum wlr_output_state_mode_type {
@@ -108,6 +110,13 @@ struct wlr_output_state {
 
 	struct wlr_output_layer_state *layers;
 	size_t layers_len;
+
+	// only valid if WLR_OUTPUT_STATE_WAIT_TIMELINE
+	struct wlr_render_timeline *wait_timeline;
+	uint64_t wait_point;
+	// only valid if WLR_OUTPUT_STATE_SIGNAL_TIMELINE
+	struct wlr_render_timeline *signal_timeline;
+	uint64_t signal_point;
 };
 
 struct wlr_output_impl;
@@ -535,6 +544,31 @@ void wlr_output_state_set_damage(struct wlr_output_state *state,
  */
 void wlr_output_state_set_layers(struct wlr_output_state *state,
 	struct wlr_output_layer_state *layers, size_t layers_len);
+/**
+ * Set a timeline point to wait on before displaying the next frame.
+ *
+ * The timeline must continue to remain valid until the next call to
+ * wlr_output_commit() or wlr_output_rollback(). Committing a wait timeline
+ * point without a buffer is invalid.
+ *
+ * There is only a single wait timeline point, waiting for multiple timeline
+ * points is unsupported.
+ */
+void wlr_output_state_set_wait_timeline(struct wlr_output_state *state,
+	struct wlr_render_timeline *timeline, uint64_t src_point);
+/**
+ * Set a timeline point to be signalled when the frame is no longer being used
+ * by the backend.
+ *
+ * The timeline must continue to remain valid until the next call to
+ * wlr_output_commit() or wlr_output_rollback(). Committing a signal timeline
+ * point without a buffer is invalid.
+ *
+ * There is only a single signal timeline point, signalling multiple timeline
+ * points is unsupported.
+ */
+void wlr_output_state_set_signal_timeline(struct wlr_output_state *state,
+	struct wlr_render_timeline *timeline, uint64_t dst_point);
 
 /**
  * Copies the output state from src to dst. It is safe to then
diff --git a/types/output/output.c b/types/output/output.c
index 4376da9911..9c6e5115d8 100644
--- a/types/output/output.c
+++ b/types/output/output.c
@@ -563,9 +563,19 @@ static bool output_basic_test(struct wlr_output *output,
 			wlr_log(WLR_DEBUG, "Primary buffer size mismatch");
 			return false;
 		}
-	} else if (state->tearing_page_flip) {
-		wlr_log(WLR_ERROR, "Trying to commit a tearing page flip without a buffer?");
-		return false;
+	} else {
+		if (state->tearing_page_flip) {
+			wlr_log(WLR_ERROR, "Tried to commit a tearing page flip without a buffer");
+			return false;
+		}
+		if (state->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+			wlr_log(WLR_DEBUG, "Tried to set wait timeline without a buffer");
+			return false;
+		}
+		if (state->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+			wlr_log(WLR_DEBUG, "Tried to set signal timeline without a buffer");
+			return false;
+		}
 	}
 
 	if (state->committed & WLR_OUTPUT_STATE_RENDER_FORMAT) {
diff --git a/types/output/state.c b/types/output/state.c
index 0909b3e8ac..d33470f572 100644
--- a/types/output/state.c
+++ b/types/output/state.c
@@ -114,6 +114,20 @@ void wlr_output_state_set_layers(struct wlr_output_state *state,
 	state->layers_len = layers_len;
 }
 
+void wlr_output_state_set_wait_timeline(struct wlr_output_state *state,
+		struct wlr_render_timeline *timeline, uint64_t src_point) {
+	state->committed |= WLR_OUTPUT_STATE_WAIT_TIMELINE;
+	state->wait_timeline = timeline;
+	state->wait_point = src_point;
+}
+
+void wlr_output_state_set_signal_timeline(struct wlr_output_state *state,
+		struct wlr_render_timeline *timeline, uint64_t dst_point) {
+	state->committed |= WLR_OUTPUT_STATE_SIGNAL_TIMELINE;
+	state->signal_timeline = timeline;
+	state->signal_point = dst_point;
+}
+
 bool wlr_output_state_copy(struct wlr_output_state *dst,
 		const struct wlr_output_state *src) {
 	struct wlr_output_state copy = *src;
-- 
GitLab


From 91e8a8aafc044ae5e12c31a70caefaf281ed2d57 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Wed, 20 Oct 2021 20:09:38 +0200
Subject: [PATCH 06/14] backend/drm: add support for explicit sync APIs

---
 backend/drm/atomic.c             | 53 ++++++++++++++++++++++++++++++++
 backend/drm/drm.c                | 12 +++++++-
 backend/drm/legacy.c             |  7 +++++
 backend/drm/libliftoff.c         |  8 +++++
 backend/drm/properties.c         |  2 ++
 include/backend/drm/properties.h |  2 ++
 6 files changed, 83 insertions(+), 1 deletion(-)

diff --git a/backend/drm/atomic.c b/backend/drm/atomic.c
index c190a9fd3b..9059a1a533 100644
--- a/backend/drm/atomic.c
+++ b/backend/drm/atomic.c
@@ -1,6 +1,8 @@
 #include <drm_fourcc.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <unistd.h>
+#include <wlr/render/timeline.h>
 #include <wlr/util/log.h>
 #include <xf86drm.h>
 #include <xf86drmMode.h>
@@ -268,6 +270,41 @@ static void set_plane_props(struct atomic *atom, struct wlr_drm_backend *drm,
 	atomic_add(atom, id, props->crtc_y, (uint64_t)y);
 }
 
+static int set_plane_in_fence_fd(struct atomic *atom, struct wlr_drm_plane *plane,
+		struct wlr_render_timeline *timeline, uint64_t src_point) {
+	if (!plane->props.in_fence_fd) {
+		wlr_log(WLR_ERROR, "Missing IN_FENCE_FD property");
+		goto error;
+	}
+
+	int sync_file_fd = wlr_render_timeline_export_sync_file(timeline, src_point);
+	if (sync_file_fd < 0) {
+		goto error;
+	}
+
+	atomic_add(atom, plane->id, plane->props.in_fence_fd, sync_file_fd);
+
+	return sync_file_fd;
+
+error:
+	wlr_log(WLR_ERROR, "Failed to set plane %"PRIu32" IN_FENCE_FD", plane->id);
+	atom->failed = true;
+	return -1;
+}
+
+static void set_crtc_out_fence_ptr(struct atomic *atom, struct wlr_drm_crtc *crtc,
+		int *fd_ptr) {
+	if (!crtc->props.out_fence_ptr) {
+		wlr_log(WLR_ERROR,
+			"CRTC %"PRIu32" is missing the OUT_FENCE_PTR property",
+			crtc->id);
+		atom->failed = true;
+		return;
+	}
+
+	atomic_add(atom, crtc->id, crtc->props.out_fence_ptr, (uintptr_t)fd_ptr);
+}
+
 static bool atomic_crtc_commit(struct wlr_drm_connector *conn,
 		const struct wlr_drm_connector_state *state,
 		struct wlr_drm_page_flip *page_flip, uint32_t flags, bool test_only) {
@@ -331,6 +368,8 @@ static bool atomic_crtc_commit(struct wlr_drm_connector *conn,
 		flags |= DRM_MODE_ATOMIC_NONBLOCK;
 	}
 
+	int in_fence_fd = -1, out_fence_fd = -1;
+
 	struct atomic atom;
 	atomic_begin(&atom);
 	atomic_add(&atom, conn->id, conn->props.crtc_id, active ? crtc->id : 0);
@@ -360,6 +399,13 @@ static bool atomic_crtc_commit(struct wlr_drm_connector *conn,
 			atomic_add(&atom, crtc->primary->id,
 				crtc->primary->props.fb_damage_clips, fb_damage_clips);
 		}
+		if (state->base->committed & WLR_OUTPUT_STATE_WAIT_TIMELINE) {
+			in_fence_fd = set_plane_in_fence_fd(&atom, crtc->primary,
+				state->base->wait_timeline, state->base->wait_point);
+		}
+		if (state->base->committed & WLR_OUTPUT_STATE_SIGNAL_TIMELINE) {
+			set_crtc_out_fence_ptr(&atom, crtc, &out_fence_fd);
+		}
 		if (crtc->cursor) {
 			if (drm_connector_is_cursor_visible(conn)) {
 				set_plane_props(&atom, drm, crtc->cursor, get_next_cursor_fb(conn),
@@ -393,11 +439,18 @@ static bool atomic_crtc_commit(struct wlr_drm_connector *conn,
 			wlr_drm_conn_log(conn, WLR_DEBUG, "VRR %s",
 				vrr_enabled ? "enabled" : "disabled");
 		}
+
+		if (out_fence_fd >= 0) {
+			ok = wlr_render_timeline_import_sync_file(state->base->signal_timeline,
+				state->base->signal_point, out_fence_fd);
+			close(out_fence_fd);
+		}
 	} else {
 		rollback_blob(drm, &crtc->mode_id, mode_id);
 		rollback_blob(drm, &crtc->gamma_lut, gamma_lut);
 	}
 	destroy_blob(drm, fb_damage_clips);
+	close(in_fence_fd);
 
 	return ok;
 }
diff --git a/backend/drm/drm.c b/backend/drm/drm.c
index 41a38f6dd6..6a9b3578b5 100644
--- a/backend/drm/drm.c
+++ b/backend/drm/drm.c
@@ -41,7 +41,9 @@ static const uint32_t COMMIT_OUTPUT_STATE =
 	WLR_OUTPUT_STATE_ENABLED |
 	WLR_OUTPUT_STATE_GAMMA_LUT |
 	WLR_OUTPUT_STATE_ADAPTIVE_SYNC_ENABLED |
-	WLR_OUTPUT_STATE_LAYERS;
+	WLR_OUTPUT_STATE_LAYERS |
+	WLR_OUTPUT_STATE_WAIT_TIMELINE |
+	WLR_OUTPUT_STATE_SIGNAL_TIMELINE;
 
 static const uint32_t SUPPORTED_OUTPUT_STATE =
 	WLR_OUTPUT_STATE_BACKEND_OPTIONAL | COMMIT_OUTPUT_STATE;
@@ -672,6 +674,14 @@ static bool drm_connector_test(struct wlr_output *output,
 		}
 	}
 
+	// TODO: support sync timelines in multi-GPU mode
+	if ((state->committed & (WLR_OUTPUT_STATE_WAIT_TIMELINE |
+			WLR_OUTPUT_STATE_SIGNAL_TIMELINE)) && conn->backend->parent) {
+		wlr_drm_conn_log(conn, WLR_DEBUG,
+			"Sync timelines are unsupported in multi-GPU mode");
+		return false;
+	}
+
 	bool ok = false;
 	struct wlr_drm_connector_state pending = {0};
 	drm_connector_state_init(&pending, conn, state);
diff --git a/backend/drm/legacy.c b/backend/drm/legacy.c
index 1e62f61f7c..a776062828 100644
--- a/backend/drm/legacy.c
+++ b/backend/drm/legacy.c
@@ -55,6 +55,13 @@ static bool legacy_crtc_test(struct wlr_drm_connector *conn,
 		}
 	}
 
+	if (state->base->committed & (WLR_OUTPUT_STATE_WAIT_TIMELINE |
+			WLR_OUTPUT_STATE_SIGNAL_TIMELINE)) {
+		wlr_drm_conn_log(conn, WLR_DEBUG,
+			"Sync timelines are unsupported with legacy KMS interface");
+		return false;
+	}
+
 	return true;
 }
 
diff --git a/backend/drm/libliftoff.c b/backend/drm/libliftoff.c
index 79f8395496..12cbf449ee 100644
--- a/backend/drm/libliftoff.c
+++ b/backend/drm/libliftoff.c
@@ -310,6 +310,14 @@ static bool crtc_commit(struct wlr_drm_connector *conn,
 	bool modeset = state->modeset;
 	bool active = state->active;
 
+	// TODO: support sync timelines
+	if (state->base->committed & (WLR_OUTPUT_STATE_WAIT_TIMELINE |
+			WLR_OUTPUT_STATE_SIGNAL_TIMELINE)) {
+		wlr_drm_conn_log(conn, WLR_DEBUG,
+			"Sync timelines are unsupported with libliftoff KMS interface");
+		return false;
+	}
+
 	if (modeset && !register_planes_for_crtc(drm, crtc)) {
 		return false;
 	}
diff --git a/backend/drm/properties.c b/backend/drm/properties.c
index ecd0d910e6..94ecb4593b 100644
--- a/backend/drm/properties.c
+++ b/backend/drm/properties.c
@@ -40,6 +40,7 @@ static const struct prop_info crtc_info[] = {
 	{ "GAMMA_LUT", INDEX(gamma_lut) },
 	{ "GAMMA_LUT_SIZE", INDEX(gamma_lut_size) },
 	{ "MODE_ID", INDEX(mode_id) },
+	{ "OUT_FENCE_PTR", INDEX(out_fence_ptr) },
 	{ "VRR_ENABLED", INDEX(vrr_enabled) },
 #undef INDEX
 };
@@ -53,6 +54,7 @@ static const struct prop_info plane_info[] = {
 	{ "CRTC_Y", INDEX(crtc_y) },
 	{ "FB_DAMAGE_CLIPS", INDEX(fb_damage_clips) },
 	{ "FB_ID", INDEX(fb_id) },
+	{ "IN_FENCE_FD", INDEX(in_fence_fd) },
 	{ "IN_FORMATS", INDEX(in_formats) },
 	{ "SRC_H", INDEX(src_h) },
 	{ "SRC_W", INDEX(src_w) },
diff --git a/include/backend/drm/properties.h b/include/backend/drm/properties.h
index 4ce957678c..3e8307b4bb 100644
--- a/include/backend/drm/properties.h
+++ b/include/backend/drm/properties.h
@@ -42,6 +42,7 @@ union wlr_drm_crtc_props {
 
 		uint32_t active;
 		uint32_t mode_id;
+		uint32_t out_fence_ptr;
 	};
 	uint32_t props[6];
 };
@@ -65,6 +66,7 @@ union wlr_drm_plane_props {
 		uint32_t fb_id;
 		uint32_t crtc_id;
 		uint32_t fb_damage_clips;
+		uint32_t in_fence_fd;
 	};
 	uint32_t props[14];
 };
-- 
GitLab


From 2be6e78fa7fc62a8e21c65fe4cdc810b8998d2fb Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Sun, 15 Mar 2020 15:02:04 +0100
Subject: [PATCH 07/14] linux-explicit-synchronization-v1: new protocol
 implementation

This patch adds support for the
linux-explicit-synchronization-unstable-v1 protocol.

To test, run weston-simple-dmabuf-egl.
---
 .../wlr_linux_explicit_synchronization_v1.h   |  82 ++++
 protocol/meson.build                          |   1 +
 types/meson.build                             |   1 +
 types/wlr_linux_explicit_synchronization_v1.c | 393 ++++++++++++++++++
 4 files changed, 477 insertions(+)
 create mode 100644 include/wlr/types/wlr_linux_explicit_synchronization_v1.h
 create mode 100644 types/wlr_linux_explicit_synchronization_v1.c

diff --git a/include/wlr/types/wlr_linux_explicit_synchronization_v1.h b/include/wlr/types/wlr_linux_explicit_synchronization_v1.h
new file mode 100644
index 0000000000..fa183000c2
--- /dev/null
+++ b/include/wlr/types/wlr_linux_explicit_synchronization_v1.h
@@ -0,0 +1,82 @@
+/*
+ * This an unstable interface of wlroots. No guarantees are made regarding the
+ * future consistency of this API.
+ */
+#ifndef WLR_USE_UNSTABLE
+#error "Add -DWLR_USE_UNSTABLE to enable unstable wlroots features"
+#endif
+
+#ifndef WLR_TYPES_WLR_LINUX_EXPLICIT_SYNCHRONIZATION_V1_H
+#define WLR_TYPES_WLR_LINUX_EXPLICIT_SYNCHRONIZATION_V1_H
+
+#include <wayland-server-core.h>
+#include <wlr/types/wlr_compositor.h>
+#include <wlr/util/addon.h>
+
+struct wlr_linux_surface_synchronization_v1_state {
+	int acquire_fence_fd;
+	struct wlr_linux_buffer_release_v1 *buffer_release;
+};
+
+struct wlr_linux_surface_synchronization_v1 {
+	struct wl_resource *resource;
+	struct wlr_surface *surface;
+
+	// private state
+
+	struct wlr_addon addon;
+	struct wlr_surface_synced synced;
+
+	struct wlr_linux_surface_synchronization_v1_state pending, current;
+
+	struct wl_listener client_commit;
+};
+
+struct wlr_linux_buffer_release_v1 {
+	struct wl_resource *resource;
+};
+
+struct wlr_linux_explicit_synchronization_v1 {
+	struct wl_global *global;
+
+	struct {
+		struct wl_signal destroy;
+	} events;
+
+	// private state
+
+	struct wl_listener display_destroy;
+};
+
+/**
+ * Advertise explicit synchronization support to clients.
+ *
+ * The compositor must be prepared to handle fences coming from clients and to
+ * send release fences correctly. In particular, both the renderer and the
+ * backend need to support explicit synchronization.
+ */
+struct wlr_linux_explicit_synchronization_v1 *
+wlr_linux_explicit_synchronization_v1_create(struct wl_display *display);
+
+/**
+ * Signal the provided timeline synchronization point when the last submitted
+ * buffer is ready to be acquired.
+ */
+bool wlr_linux_explicit_synchronization_v1_signal_surface_timeline(
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync,
+	struct wlr_surface *surface, struct wlr_render_timeline *timeline,
+	uint64_t dst_point);
+
+/**
+ * Send a timeline synchronization point to the client which can be used to
+ * wait for the buffer to be released.
+ *
+ * The synchronization point must already be materialized: wait-before-submit
+ * is not supported.
+ */
+bool wlr_linux_explicit_synchronization_v1_wait_surface_timeline(
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync,
+	struct wlr_surface *surface, struct wlr_render_timeline *timeline,
+	uint64_t src_point);
+
+#endif
diff --git a/protocol/meson.build b/protocol/meson.build
index 6a8d82b4ff..e63b4aeffb 100644
--- a/protocol/meson.build
+++ b/protocol/meson.build
@@ -36,6 +36,7 @@ protocols = {
 	'fullscreen-shell-unstable-v1': wl_protocol_dir / 'unstable/fullscreen-shell/fullscreen-shell-unstable-v1.xml',
 	'idle-inhibit-unstable-v1': wl_protocol_dir / 'unstable/idle-inhibit/idle-inhibit-unstable-v1.xml',
 	'keyboard-shortcuts-inhibit-unstable-v1': wl_protocol_dir / 'unstable/keyboard-shortcuts-inhibit/keyboard-shortcuts-inhibit-unstable-v1.xml',
+	'linux-explicit-synchronization-unstable-v1': wl_protocol_dir / 'unstable/linux-explicit-synchronization/linux-explicit-synchronization-unstable-v1.xml',
 	'pointer-constraints-unstable-v1': wl_protocol_dir / 'unstable/pointer-constraints/pointer-constraints-unstable-v1.xml',
 	'pointer-gestures-unstable-v1': wl_protocol_dir / 'unstable/pointer-gestures/pointer-gestures-unstable-v1.xml',
 	'primary-selection-unstable-v1': wl_protocol_dir / 'unstable/primary-selection/primary-selection-unstable-v1.xml',
diff --git a/types/meson.build b/types/meson.build
index 8962a390eb..0ab0ee0feb 100644
--- a/types/meson.build
+++ b/types/meson.build
@@ -54,6 +54,7 @@ wlr_files += files(
 	'wlr_keyboard_shortcuts_inhibit_v1.c',
 	'wlr_layer_shell_v1.c',
 	'wlr_linux_dmabuf_v1.c',
+	'wlr_linux_explicit_synchronization_v1.c',
 	'wlr_matrix.c',
 	'wlr_output_layer.c',
 	'wlr_output_layout.c',
diff --git a/types/wlr_linux_explicit_synchronization_v1.c b/types/wlr_linux_explicit_synchronization_v1.c
new file mode 100644
index 0000000000..02a8df67cc
--- /dev/null
+++ b/types/wlr_linux_explicit_synchronization_v1.c
@@ -0,0 +1,393 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <wlr/render/timeline.h>
+#include <wlr/types/wlr_linux_explicit_synchronization_v1.h>
+#include <wlr/types/wlr_compositor.h>
+#include "linux-explicit-synchronization-unstable-v1-protocol.h"
+
+#define LINUX_EXPLICIT_SYNCHRONIZATION_V1_VERSION 2
+
+static const struct zwp_linux_explicit_synchronization_v1_interface
+	explicit_sync_impl;
+static const struct zwp_linux_surface_synchronization_v1_interface
+	surface_sync_impl;
+
+static struct wlr_linux_explicit_synchronization_v1 *
+explicit_sync_from_resource(struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&zwp_linux_explicit_synchronization_v1_interface,
+		&explicit_sync_impl));
+	return wl_resource_get_user_data(resource);
+}
+
+// Returns NULL if the surface sync is inert
+static struct wlr_linux_surface_synchronization_v1 *
+surface_sync_from_resource(struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&zwp_linux_surface_synchronization_v1_interface,
+		&surface_sync_impl));
+	return wl_resource_get_user_data(resource);
+}
+
+static struct wlr_linux_buffer_release_v1 *buffer_release_from_resource(
+		struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&zwp_linux_buffer_release_v1_interface, NULL));
+	return wl_resource_get_user_data(resource);
+}
+
+static void buffer_release_destroy(
+		struct wlr_linux_buffer_release_v1 *buffer_release, int fence_fd) {
+	if (buffer_release == NULL) {
+		return;
+	}
+	if (fence_fd >= 0) {
+		zwp_linux_buffer_release_v1_send_fenced_release(
+			buffer_release->resource, fence_fd);
+	} else {
+		zwp_linux_buffer_release_v1_send_immediate_release(
+			buffer_release->resource);
+	}
+	wl_resource_destroy(buffer_release->resource);
+}
+
+static void buffer_release_handle_resource_destroy(struct wl_resource *resource) {
+	struct wlr_linux_buffer_release_v1 *buffer_release =
+		buffer_release_from_resource(resource);
+	free(buffer_release);
+}
+
+static void surface_sync_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static void surface_sync_handle_set_acquire_fence(struct wl_client *client,
+		struct wl_resource *resource, int fence_fd) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		surface_sync_from_resource(resource);
+	if (surface_sync == NULL) {
+		close(fence_fd);
+		wl_resource_post_error(resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_NO_SURFACE,
+			"the surface has been destroyed");
+		return;
+	}
+
+	if (surface_sync->pending.acquire_fence_fd >= 0) {
+		close(fence_fd);
+		wl_resource_post_error(resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_DUPLICATE_FENCE,
+			"a fence FD was already set for this commit");
+		return;
+	}
+
+	// TODO: check that the FD is a sync_file
+
+	surface_sync->pending.acquire_fence_fd = fence_fd;
+}
+
+static void surface_sync_handle_get_release(struct wl_client *client,
+		struct wl_resource *resource, uint32_t id) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		surface_sync_from_resource(resource);
+	if (surface_sync == NULL) {
+		wl_resource_post_error(resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_NO_SURFACE,
+			"the surface has been destroyed");
+		return;
+	}
+
+	if (surface_sync->pending.buffer_release != NULL) {
+		wl_resource_post_error(resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_DUPLICATE_RELEASE,
+			"a buffer release has already been requested for this commit");
+		return;
+	}
+
+	struct wlr_linux_buffer_release_v1 *buffer_release =
+		calloc(1, sizeof(*buffer_release));
+	if (buffer_release == NULL) {
+		wl_resource_post_no_memory(resource);
+		return;
+	}
+
+	uint32_t version = wl_resource_get_version(resource);
+	buffer_release->resource = wl_resource_create(client,
+		&zwp_linux_buffer_release_v1_interface, version, id);
+	if (buffer_release->resource == NULL) {
+		wl_resource_post_no_memory(resource);
+		free(buffer_release);
+		return;
+	}
+	wl_resource_set_implementation(buffer_release->resource, NULL,
+		buffer_release, buffer_release_handle_resource_destroy);
+
+	surface_sync->pending.buffer_release = buffer_release;
+}
+
+static const struct zwp_linux_surface_synchronization_v1_interface
+		surface_sync_impl = {
+	.destroy = surface_sync_handle_destroy,
+	.set_acquire_fence = surface_sync_handle_set_acquire_fence,
+	.get_release = surface_sync_handle_get_release,
+};
+
+static void surface_sync_state_init(
+		struct wlr_linux_surface_synchronization_v1_state *state) {
+	*state = (struct wlr_linux_surface_synchronization_v1_state){
+		.acquire_fence_fd = -1,
+	};
+}
+
+static void surface_sync_state_finish(
+		struct wlr_linux_surface_synchronization_v1_state *state) {
+	if (state->acquire_fence_fd >= 0) {
+		close(state->acquire_fence_fd);
+	}
+	buffer_release_destroy(state->buffer_release, -1);
+}
+
+static void surface_sync_destroy(
+		struct wlr_linux_surface_synchronization_v1 *surface_sync) {
+	if (surface_sync == NULL) {
+		return;
+	}
+	wl_list_remove(&surface_sync->client_commit.link);
+	wlr_surface_synced_finish(&surface_sync->synced);
+	wlr_addon_finish(&surface_sync->addon);
+	wl_resource_set_user_data(surface_sync->resource, NULL);
+	surface_sync_state_finish(&surface_sync->pending);
+	surface_sync_state_finish(&surface_sync->current);
+	free(surface_sync);
+}
+
+static void surface_sync_handle_resource_destroy(struct wl_resource *resource) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		surface_sync_from_resource(resource);
+	surface_sync_destroy(surface_sync);
+}
+
+static void surface_sync_handle_surface_destroy(struct wlr_addon *addon) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		wl_container_of(addon, surface_sync, addon);
+	surface_sync_destroy(surface_sync);
+}
+
+static const struct wlr_addon_interface addon_impl = {
+	.name = "zwp_linux_surface_synchronization_v1",
+	.destroy = surface_sync_handle_surface_destroy,
+};
+
+static void surface_synced_init_state(void *_state) {
+	struct wlr_linux_surface_synchronization_v1_state *state = _state;
+	surface_sync_state_init(state);
+}
+
+static void surface_synced_finish_state(void *_state) {
+	struct wlr_linux_surface_synchronization_v1_state *state = _state;
+	surface_sync_state_finish(state);
+}
+
+static void surface_synced_move_state(void *_dst, void *_src) {
+	struct wlr_linux_surface_synchronization_v1_state *dst = _dst, *src = _src;
+	surface_sync_state_finish(dst);
+	*dst = *src;
+	surface_sync_state_init(src);
+}
+
+static const struct wlr_surface_synced_impl surface_synced_impl = {
+	.state_size = sizeof(struct wlr_linux_surface_synchronization_v1_state),
+	.init_state = surface_synced_init_state,
+	.finish_state = surface_synced_finish_state,
+	.move_state = surface_synced_move_state,
+};
+
+static void explicit_sync_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static struct wlr_linux_surface_synchronization_v1 *surface_sync_from_surface(
+		struct wlr_linux_explicit_synchronization_v1 *explicit_sync,
+		struct wlr_surface *surface) {
+	struct wlr_addon *addon =
+		wlr_addon_find(&surface->addons, explicit_sync, &addon_impl);
+	if (addon == NULL) {
+		return NULL;
+	}
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		wl_container_of(addon, surface_sync, addon);
+	return surface_sync;
+}
+
+static void surface_sync_handle_client_commit(struct wl_listener *listener,
+		void *data) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		wl_container_of(listener, surface_sync, client_commit);
+
+	if (surface_sync->pending.acquire_fence_fd >= 0 &&
+			surface_sync->surface->buffer == NULL) {
+		wl_resource_post_error(surface_sync->resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_NO_BUFFER,
+			"acquire fence FD set but no buffer attached");
+		return;
+	}
+
+	if (surface_sync->pending.buffer_release != NULL &&
+			surface_sync->surface->buffer == NULL) {
+		wl_resource_post_error(surface_sync->resource,
+			ZWP_LINUX_SURFACE_SYNCHRONIZATION_V1_ERROR_NO_BUFFER,
+			"buffer release requested but no buffer attached");
+		return;
+	}
+}
+
+static void explicit_sync_handle_get_synchronization(struct wl_client *client,
+		struct wl_resource *resource, uint32_t id,
+		struct wl_resource *surface_resource) {
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync =
+		explicit_sync_from_resource(resource);
+	struct wlr_surface *surface = wlr_surface_from_resource(surface_resource);
+
+	if (surface_sync_from_surface(explicit_sync, surface) != NULL) {
+		wl_resource_post_error(resource,
+			ZWP_LINUX_EXPLICIT_SYNCHRONIZATION_V1_ERROR_SYNCHRONIZATION_EXISTS,
+			"zwp_linux_surface_synchronization_v1 already created for this surface");
+		return;
+	}
+
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		calloc(1, sizeof(*surface_sync));
+	if (surface_sync == NULL) {
+		goto error_surface_sync;
+	}
+
+	if (!wlr_surface_synced_init(&surface_sync->synced, surface,
+			&surface_synced_impl, &surface_sync->pending, &surface_sync->current)) {
+		goto error_surface_sync;
+	}
+
+	uint32_t version = wl_resource_get_version(resource);
+	surface_sync->resource = wl_resource_create(client,
+		&zwp_linux_surface_synchronization_v1_interface, version, id);
+	if (surface_sync->resource == NULL) {
+		goto error_synced;
+	}
+	wl_resource_set_implementation(surface_sync->resource,
+		&surface_sync_impl, surface_sync, surface_sync_handle_resource_destroy);
+
+	surface_sync->surface = surface;
+
+	wlr_addon_init(&surface_sync->addon, &surface->addons, explicit_sync,
+		&addon_impl);
+
+	surface_sync->client_commit.notify = surface_sync_handle_client_commit;
+	wl_signal_add(&surface->events.client_commit, &surface_sync->client_commit);
+
+	return;
+
+error_synced:
+	wlr_surface_synced_finish(&surface_sync->synced);
+error_surface_sync:
+	free(surface_sync);
+	wl_resource_post_no_memory(resource);
+}
+
+static const struct zwp_linux_explicit_synchronization_v1_interface
+		explicit_sync_impl = {
+	.destroy = explicit_sync_handle_destroy,
+	.get_synchronization = explicit_sync_handle_get_synchronization,
+};
+
+static void explicit_sync_bind(struct wl_client *client, void *data,
+		uint32_t version, uint32_t id) {
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync = data;
+
+	struct wl_resource *resource = wl_resource_create(client,
+		&zwp_linux_explicit_synchronization_v1_interface, version, id);
+	if (resource == NULL) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+	wl_resource_set_implementation(resource, &explicit_sync_impl,
+		explicit_sync, NULL);
+}
+
+static void handle_display_destroy(struct wl_listener *listener, void *data) {
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync =
+		wl_container_of(listener, explicit_sync, display_destroy);
+	wl_signal_emit_mutable(&explicit_sync->events.destroy, NULL);
+	wl_list_remove(&explicit_sync->display_destroy.link);
+	wl_global_destroy(explicit_sync->global);
+	free(explicit_sync);
+}
+
+struct wlr_linux_explicit_synchronization_v1 *
+wlr_linux_explicit_synchronization_v1_create(struct wl_display *display) {
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync =
+		calloc(1, sizeof(*explicit_sync));
+	if (explicit_sync == NULL) {
+		return NULL;
+	}
+
+	wl_signal_init(&explicit_sync->events.destroy);
+
+	explicit_sync->global = wl_global_create(display,
+		&zwp_linux_explicit_synchronization_v1_interface,
+		LINUX_EXPLICIT_SYNCHRONIZATION_V1_VERSION, explicit_sync,
+		explicit_sync_bind);
+	if (explicit_sync->global == NULL) {
+		free(explicit_sync);
+		return NULL;
+	}
+
+	explicit_sync->display_destroy.notify = handle_display_destroy;
+	wl_display_add_destroy_listener(display, &explicit_sync->display_destroy);
+
+	return explicit_sync;
+}
+
+bool wlr_linux_explicit_synchronization_v1_signal_surface_timeline(
+		struct wlr_linux_explicit_synchronization_v1 *explicit_sync,
+		struct wlr_surface *surface, struct wlr_render_timeline *timeline,
+		uint64_t dst_point) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		surface_sync_from_surface(explicit_sync, surface);
+	if (!surface_sync) {
+		// TODO: fallback to DMA-BUF fence export
+		return false;
+	}
+
+	return wlr_render_timeline_import_sync_file(timeline, dst_point,
+		surface_sync->current.acquire_fence_fd);
+}
+
+bool wlr_linux_explicit_synchronization_v1_wait_surface_timeline(
+		struct wlr_linux_explicit_synchronization_v1 *explicit_sync,
+		struct wlr_surface *surface, struct wlr_render_timeline *timeline,
+		uint64_t src_point) {
+	struct wlr_linux_surface_synchronization_v1 *surface_sync =
+		surface_sync_from_surface(explicit_sync, surface);
+	if (!surface_sync) {
+		return true;
+	}
+
+	struct wlr_linux_buffer_release_v1 *buffer_release =
+		surface_sync->current.buffer_release;
+	surface_sync->current.buffer_release = NULL;
+	if (!buffer_release) {
+		return true;
+	}
+
+	int fence_fd = wlr_render_timeline_export_sync_file(timeline, src_point);
+	if (fence_fd < 0) {
+		return false;
+	}
+
+	buffer_release_destroy(buffer_release, fence_fd);
+	close(fence_fd);
+	return true;
+}
-- 
GitLab


From 8fe28361c5de78b86d48a2fd06c31ab19503ed1f Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Wed, 20 Oct 2021 22:00:39 +0200
Subject: [PATCH 08/14] examples/explicit-sync: new example

---
 examples/explicit-sync.c | 258 +++++++++++++++++++++++++++++++++++++++
 examples/meson.build     |   4 +
 2 files changed, 262 insertions(+)
 create mode 100644 examples/explicit-sync.c

diff --git a/examples/explicit-sync.c b/examples/explicit-sync.c
new file mode 100644
index 0000000000..22c10df841
--- /dev/null
+++ b/examples/explicit-sync.c
@@ -0,0 +1,258 @@
+#include <assert.h>
+#include <getopt.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <unistd.h>
+#include <wayland-server-core.h>
+#include <wlr/backend.h>
+#include <wlr/render/allocator.h>
+#include <wlr/render/swapchain.h>
+#include <wlr/render/timeline.h>
+#include <wlr/render/wlr_renderer.h>
+#include <wlr/types/wlr_compositor.h>
+#include <wlr/types/wlr_linux_explicit_synchronization_v1.h>
+#include <wlr/types/wlr_output.h>
+#include <wlr/types/wlr_xdg_shell.h>
+#include <wlr/util/log.h>
+
+/* Simple compositor with explicit synchronization support. Input is
+ * unimplemented.
+ *
+ * New surfaces are stacked on top of the existing ones as they appear. */
+
+struct server {
+	struct wl_display *display;
+	struct wlr_backend *backend;
+	struct wlr_allocator *allocator;
+	struct wlr_renderer *renderer;
+	struct wlr_linux_explicit_synchronization_v1 *explicit_sync_v1;
+
+	struct wl_list outputs;
+	struct wl_list surfaces;
+
+	struct wl_listener new_output;
+	struct wl_listener new_surface;
+};
+
+struct surface {
+	struct wlr_surface *wlr;
+	struct wl_list link;
+
+	struct wlr_render_timeline *timeline;
+
+	struct wl_listener destroy;
+};
+
+struct output {
+	struct wl_list link;
+	struct server *server;
+	struct wlr_output *wlr;
+
+	struct wlr_render_timeline *in_timeline, *out_timeline;
+
+	struct wl_listener frame;
+};
+
+static void output_handle_frame(struct wl_listener *listener, void *data) {
+	struct output *output = wl_container_of(listener, output, frame);
+	struct wlr_renderer *renderer = output->server->renderer;
+
+	wlr_output_configure_primary_swapchain(output->wlr, NULL, &output->wlr->swapchain);
+
+	uint64_t output_point = output->wlr->commit_seq;
+	struct wlr_buffer *buffer = wlr_swapchain_acquire(output->wlr->swapchain, NULL);
+	struct wlr_render_pass *pass = wlr_renderer_begin_buffer_pass(renderer, buffer, &(struct wlr_buffer_pass_options){
+		.signal_timeline = output->in_timeline,
+		.signal_point = output_point,
+	});
+
+	wlr_render_pass_add_rect(pass, &(struct wlr_render_rect_options){
+		.box = { .width = output->wlr->width, .height = output->wlr->height },
+		.color = { 0.25, 0.25, 0.25, 1 },
+	});
+
+	struct timespec now;
+	clock_gettime(CLOCK_MONOTONIC, &now);
+
+	int pos = 0;
+	struct surface *surface;
+	wl_list_for_each(surface, &output->server->surfaces, link) {
+		pos += 50;
+
+		struct wlr_texture *texture = wlr_surface_get_texture(surface->wlr);
+		if (texture == NULL) {
+			continue;
+		}
+
+		uint64_t surface_point = surface->wlr->current.seq;
+		if (!wlr_linux_explicit_synchronization_v1_signal_surface_timeline(
+				output->server->explicit_sync_v1, surface->wlr,
+				surface->timeline, surface_point)) {
+			wlr_log(WLR_ERROR, "Failed to signal surface timeline");
+			continue;
+		}
+
+		wlr_render_pass_add_texture(pass, &(struct wlr_render_texture_options){
+			.texture = texture,
+			.dst_box = { .x = pos, .y = pos },
+			.wait_timeline = surface->timeline,
+			.wait_point = surface_point,
+		});
+
+		wlr_surface_send_frame_done(surface->wlr, &now);
+	}
+
+	wlr_render_pass_submit(pass);
+
+	struct wlr_output_state state;
+	wlr_output_state_init(&state);
+	wlr_output_state_set_buffer(&state, buffer);
+	wlr_buffer_unlock(buffer);
+	wlr_output_state_set_wait_timeline(&state, output->in_timeline, output_point);
+	wlr_output_state_set_signal_timeline(&state, output->out_timeline, output_point);
+	wlr_output_commit_state(output->wlr, &state);
+	wlr_output_state_finish(&state);
+
+	wl_list_for_each(surface, &output->server->surfaces, link) {
+		if (!wlr_linux_explicit_synchronization_v1_wait_surface_timeline(
+				output->server->explicit_sync_v1, surface->wlr,
+				output->out_timeline, output_point)) {
+			wlr_log(WLR_ERROR, "Failed to wait for surface timeline");
+		}
+	}
+}
+
+static void server_handle_new_output(struct wl_listener *listener, void *data) {
+	struct server *server = wl_container_of(listener, server, new_output);
+	struct wlr_output *wlr_output = data;
+
+	wlr_output_init_render(wlr_output, server->allocator, server->renderer);
+
+	int drm_fd = wlr_renderer_get_drm_fd(server->renderer);
+	struct wlr_render_timeline *in_timeline = wlr_render_timeline_create(drm_fd);
+	struct wlr_render_timeline *out_timeline = wlr_render_timeline_create(drm_fd);
+	if (in_timeline == NULL || out_timeline == NULL) {
+		return;
+	}
+
+	struct output *output = calloc(1, sizeof(*output));
+	output->wlr = wlr_output;
+	output->server = server;
+	output->in_timeline = in_timeline;
+	output->out_timeline = out_timeline;
+	output->frame.notify = output_handle_frame;
+	wl_signal_add(&wlr_output->events.frame, &output->frame);
+	wl_list_insert(&server->outputs, &output->link);
+
+	struct wlr_output_state state;
+	wlr_output_state_init(&state);
+	wlr_output_state_set_enabled(&state, true);
+	struct wlr_output_mode *mode = wlr_output_preferred_mode(wlr_output);
+	if (mode != NULL) {
+		wlr_output_state_set_mode(&state, mode);
+	}
+	wlr_output_commit_state(wlr_output, &state);
+	wlr_output_state_finish(&state);
+
+	wlr_output_create_global(wlr_output, server->display);
+}
+
+static void surface_handle_destroy(struct wl_listener *listener, void *data) {
+	struct surface *surface = wl_container_of(listener, surface, destroy);
+	wlr_render_timeline_unref(surface->timeline);
+	wl_list_remove(&surface->destroy.link);
+	wl_list_remove(&surface->link);
+	free(surface);
+}
+
+static void server_handle_new_surface(struct wl_listener *listener,
+		void *data) {
+	struct server *server = wl_container_of(listener, server, new_surface);
+	struct wlr_surface *wlr_surface = data;
+
+	int drm_fd = wlr_renderer_get_drm_fd(server->renderer);
+	struct wlr_render_timeline *timeline = wlr_render_timeline_create(drm_fd);
+	if (timeline == NULL) {
+		return;
+	}
+
+	struct surface *surface = calloc(1, sizeof(struct surface));
+	surface->wlr = wlr_surface;
+	surface->timeline = timeline;
+	surface->destroy.notify = surface_handle_destroy;
+	wl_signal_add(&wlr_surface->events.destroy, &surface->destroy);
+
+	wl_list_insert(&server->surfaces, &surface->link);
+}
+
+int main(int argc, char *argv[]) {
+	wlr_log_init(WLR_DEBUG, NULL);
+
+	const char *startup_cmd = NULL;
+	int c;
+	while ((c = getopt(argc, argv, "s:")) != -1) {
+		switch (c) {
+		case 's':
+			startup_cmd = optarg;
+			break;
+		default:
+			printf("usage: %s [-s startup-command]\n", argv[0]);
+			return EXIT_FAILURE;
+		}
+	}
+	if (optind < argc) {
+		printf("usage: %s [-s startup-command]\n", argv[0]);
+		return EXIT_FAILURE;
+	}
+
+	struct server server = {0};
+	server.display = wl_display_create();
+	struct wl_event_loop *loop = wl_display_get_event_loop(server.display);
+	server.backend = wlr_backend_autocreate(loop, NULL);
+	server.renderer = wlr_renderer_autocreate(server.backend);
+	server.allocator = wlr_allocator_autocreate(server.backend, server.renderer);
+	wlr_renderer_init_wl_display(server.renderer, server.display);
+
+	struct wlr_compositor *compositor = wlr_compositor_create(server.display, 5, server.renderer);
+
+	wlr_xdg_shell_create(server.display, 2);
+
+	server.explicit_sync_v1 = wlr_linux_explicit_synchronization_v1_create(server.display);
+
+	wl_list_init(&server.outputs);
+	wl_list_init(&server.surfaces);
+
+	server.new_output.notify = server_handle_new_output;
+	wl_signal_add(&server.backend->events.new_output, &server.new_output);
+
+	server.new_surface.notify = server_handle_new_surface;
+	wl_signal_add(&compositor->events.new_surface, &server.new_surface);
+
+	const char *socket = wl_display_add_socket_auto(server.display);
+	if (!socket) {
+		wl_display_destroy(server.display);
+		return EXIT_FAILURE;
+	}
+
+	if (!wlr_backend_start(server.backend)) {
+		wl_display_destroy(server.display);
+		return EXIT_FAILURE;
+	}
+
+	setenv("WAYLAND_DISPLAY", socket, true);
+	if (startup_cmd != NULL) {
+		if (fork() == 0) {
+			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, (void *)NULL);
+		}
+	}
+
+	wlr_log(WLR_INFO, "Running Wayland compositor on WAYLAND_DISPLAY=%s",
+		socket);
+	wl_display_run(server.display);
+
+	wl_display_destroy_clients(server.display);
+	wl_display_destroy(server.display);
+	return EXIT_SUCCESS;
+}
diff --git a/examples/meson.build b/examples/meson.build
index 3fe07df8e9..a30a63da88 100644
--- a/examples/meson.build
+++ b/examples/meson.build
@@ -51,6 +51,10 @@ compositors = {
 		],
 		'dep': [wayland_client, wayland_egl, egl, glesv2],
 	},
+	'explicit-sync': {
+		'src': 'explicit-sync.c',
+		'proto': ['xdg-shell'],
+	},
 }
 
 foreach name, info : compositors
-- 
GitLab


From 6c9bd04a676eca34e70a7a83fdb5da6d651397dc Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Wed, 20 Oct 2021 22:22:53 +0200
Subject: [PATCH 09/14] linux-explicit-synchronization-v1: extract fence from
 DMA-BUF

---
 types/wlr_linux_explicit_synchronization_v1.c | 24 +++++++++++++++----
 1 file changed, 20 insertions(+), 4 deletions(-)

diff --git a/types/wlr_linux_explicit_synchronization_v1.c b/types/wlr_linux_explicit_synchronization_v1.c
index 02a8df67cc..e4176e38a6 100644
--- a/types/wlr_linux_explicit_synchronization_v1.c
+++ b/types/wlr_linux_explicit_synchronization_v1.c
@@ -5,6 +5,7 @@
 #include <wlr/render/timeline.h>
 #include <wlr/types/wlr_linux_explicit_synchronization_v1.h>
 #include <wlr/types/wlr_compositor.h>
+#include "render/dmabuf.h"
 #include "linux-explicit-synchronization-unstable-v1-protocol.h"
 
 #define LINUX_EXPLICIT_SYNCHRONIZATION_V1_VERSION 2
@@ -356,13 +357,28 @@ bool wlr_linux_explicit_synchronization_v1_signal_surface_timeline(
 		uint64_t dst_point) {
 	struct wlr_linux_surface_synchronization_v1 *surface_sync =
 		surface_sync_from_surface(explicit_sync, surface);
-	if (!surface_sync) {
-		// TODO: fallback to DMA-BUF fence export
+	if (surface_sync) {
+		return wlr_render_timeline_import_sync_file(timeline, dst_point,
+			surface_sync->current.acquire_fence_fd);
+	}
+
+	// Client doesn't support explicit sync, try to extract the fence from the
+	// DMA-BUF
+	struct wlr_dmabuf_attributes dmabuf = {0};
+	if (surface->buffer == NULL ||
+			!wlr_buffer_get_dmabuf(&surface->buffer->base, &dmabuf)) {
+		return false;
+	}
+
+	// TODO: maybe we should wait on all planes?
+	int sync_file_fd = dmabuf_export_sync_file(dmabuf.fd[0], DMA_BUF_SYNC_READ);
+	if (sync_file_fd < 0) {
 		return false;
 	}
 
-	return wlr_render_timeline_import_sync_file(timeline, dst_point,
-		surface_sync->current.acquire_fence_fd);
+	bool ok = wlr_render_timeline_import_sync_file(timeline, dst_point, sync_file_fd);
+	close(sync_file_fd);
+	return ok;
 }
 
 bool wlr_linux_explicit_synchronization_v1_wait_surface_timeline(
-- 
GitLab


From 5ae2c8d0fd5172996c0199d867d63e74491d75a7 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Thu, 21 Oct 2021 15:02:09 +0200
Subject: [PATCH 10/14] render/timeline: add wlr_render_timeline_import()

---
 include/wlr/render/timeline.h |  5 +++++
 render/timeline.c             | 18 ++++++++++++++++++
 2 files changed, 23 insertions(+)

diff --git a/include/wlr/render/timeline.h b/include/wlr/render/timeline.h
index a286111fe3..86ef5b06c1 100644
--- a/include/wlr/render/timeline.h
+++ b/include/wlr/render/timeline.h
@@ -30,6 +30,11 @@ struct wlr_render_timeline;
  * Create a new synchronization timeline.
  */
 struct wlr_render_timeline *wlr_render_timeline_create(int drm_fd);
+/**
+ * Import a timeline from a drm_syncobj FD.
+ */
+struct wlr_render_timeline *wlr_render_timeline_import(int drm_fd,
+	int drm_syncobj_fd);
 /**
  * Reference a synchronization timeline.
  */
diff --git a/render/timeline.c b/render/timeline.c
index ec8c82bf7d..a966fa1022 100644
--- a/render/timeline.c
+++ b/render/timeline.c
@@ -27,6 +27,24 @@ struct wlr_render_timeline *wlr_render_timeline_create(int drm_fd) {
 	return timeline;
 }
 
+struct wlr_render_timeline *wlr_render_timeline_import(int drm_fd,
+		int drm_syncobj_fd) {
+	struct wlr_render_timeline *timeline = calloc(1, sizeof(*timeline));
+	if (timeline == NULL) {
+		return NULL;
+	}
+	timeline->drm_fd = drm_fd;
+	timeline->n_refs = 1;
+
+	if (drmSyncobjFDToHandle(drm_fd, drm_syncobj_fd, &timeline->handle) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjFDToHandle failed");
+		free(timeline);
+		return NULL;
+	}
+
+	return timeline;
+}
+
 struct wlr_render_timeline *wlr_render_timeline_ref(struct wlr_render_timeline *timeline) {
 	timeline->n_refs++;
 	return timeline;
-- 
GitLab


From b8c16037f58d8dc36373e138aa180ad0dd78d8d9 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Thu, 21 Oct 2021 15:23:20 +0200
Subject: [PATCH 11/14] render/timeline: add wlr_render_timeline_transfer()

---
 include/wlr/render/timeline.h |  7 +++++++
 render/timeline.c             | 13 +++++++++++++
 2 files changed, 20 insertions(+)

diff --git a/include/wlr/render/timeline.h b/include/wlr/render/timeline.h
index 86ef5b06c1..ac055102a2 100644
--- a/include/wlr/render/timeline.h
+++ b/include/wlr/render/timeline.h
@@ -43,6 +43,13 @@ struct wlr_render_timeline *wlr_render_timeline_ref(struct wlr_render_timeline *
  * Unreference a synchronization timeline.
  */
 void wlr_render_timeline_unref(struct wlr_render_timeline *timeline);
+/**
+ * Transfer a point from a timeline to another.
+ *
+ * Both timelines must have been created with the same DRM FD.
+ */
+bool wlr_render_timeline_transfer(struct wlr_render_timeline *dst,
+	uint64_t dst_point, struct wlr_render_timeline *src, uint64_t src_point);
 /**
  * Export a timeline point as a sync_file FD.
  *
diff --git a/render/timeline.c b/render/timeline.c
index a966fa1022..d23a0599f7 100644
--- a/render/timeline.c
+++ b/render/timeline.c
@@ -65,6 +65,19 @@ void wlr_render_timeline_unref(struct wlr_render_timeline *timeline) {
 	free(timeline);
 }
 
+bool wlr_render_timeline_transfer(struct wlr_render_timeline *dst,
+		uint64_t dst_point, struct wlr_render_timeline *src, uint64_t src_point) {
+	assert(dst->drm_fd == src->drm_fd);
+
+	if (drmSyncobjTransfer(dst->drm_fd, dst->handle, dst_point,
+			src->handle, src_point, 0) != 0) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjTransfer failed");
+		return false;
+	}
+
+	return true;
+}
+
 int wlr_render_timeline_export_sync_file(struct wlr_render_timeline *timeline,
 		uint64_t src_point) {
 	int sync_file_fd = -1;
-- 
GitLab


From 4bda52da8744ac779efdba94afe3a5a93892ff34 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Mon, 10 Jul 2023 17:24:09 +0200
Subject: [PATCH 12/14] render/timeline: add wlr_render_timeline_wait()

References: https://patchwork.freedesktop.org/patch/506761/
---
 include/wlr/render/timeline.h | 12 +++++
 render/meson.build            |  2 +
 render/timeline.c             | 99 +++++++++++++++++++++++++++++++++++
 3 files changed, 113 insertions(+)

diff --git a/include/wlr/render/timeline.h b/include/wlr/render/timeline.h
index ac055102a2..6a0682f8c7 100644
--- a/include/wlr/render/timeline.h
+++ b/include/wlr/render/timeline.h
@@ -4,6 +4,8 @@
 #include <stdbool.h>
 #include <stdint.h>
 
+struct wl_event_loop;
+
 /**
  * A synchronization timeline.
  *
@@ -26,6 +28,8 @@
  */
 struct wlr_render_timeline;
 
+typedef void (*wlr_render_timeline_wait_func_t)(void *data);
+
 /**
  * Create a new synchronization timeline.
  */
@@ -50,6 +54,14 @@ void wlr_render_timeline_unref(struct wlr_render_timeline *timeline);
  */
 bool wlr_render_timeline_transfer(struct wlr_render_timeline *dst,
 	uint64_t dst_point, struct wlr_render_timeline *src, uint64_t src_point);
+/**
+ * Asynchronously wait for a timeline point.
+ *
+ * Flags can only be DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE.
+ */
+struct wl_event_source *wlr_render_timeline_wait(struct wlr_render_timeline *timeline,
+	uint64_t point, uint32_t flags, struct wl_event_loop *loop,
+	wlr_render_timeline_wait_func_t func, void *data);
 /**
  * Export a timeline point as a sync_file FD.
  *
diff --git a/render/meson.build b/render/meson.build
index b4f1bc26dc..522268538d 100644
--- a/render/meson.build
+++ b/render/meson.build
@@ -22,6 +22,8 @@ else
 	wlr_files += files('dmabuf_fallback.c')
 endif
 
+internal_config.set10('HAVE_EVENTFD', cc.has_header('sys/eventfd.h'))
+
 if 'gles2' in renderers or 'auto' in renderers
 	egl = dependency('egl', required: 'gles2' in renderers)
 	gbm = dependency('gbm', required: 'gles2' in renderers)
diff --git a/render/timeline.c b/render/timeline.c
index d23a0599f7..eb891ce843 100644
--- a/render/timeline.c
+++ b/render/timeline.c
@@ -1,9 +1,17 @@
 #include <assert.h>
 #include <xf86drm.h>
 #include <stdlib.h>
+#include <unistd.h>
+#include <wayland-server-core.h>
 #include <wlr/render/timeline.h>
 #include <wlr/util/log.h>
 
+#include "config.h"
+
+#if HAVE_EVENTFD
+#include <sys/eventfd.h>
+#endif
+
 struct wlr_render_timeline {
 	int drm_fd;
 	uint32_t handle;
@@ -133,3 +141,94 @@ out:
 	drmSyncobjDestroy(timeline->drm_fd, syncobj_handle);
 	return ok;
 }
+
+#ifndef DRM_IOCTL_SYNCOBJ_EVENTFD
+
+struct drm_syncobj_eventfd {
+	__u32 handle;
+	__u32 flags;
+	__u64 point;
+	__s32 fd;
+	__u32 pad;
+};
+
+#define DRM_IOCTL_SYNCOBJ_EVENTFD DRM_IOWR(0xCE, struct drm_syncobj_eventfd)
+
+#endif
+
+struct wlr_render_timeline_waiter {
+	wlr_render_timeline_wait_func_t func;
+	void *data;
+};
+
+static int handle_eventfd_ready(int ev_fd, uint32_t mask, void *data) {
+	struct wlr_render_timeline_waiter *waiter = data;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR)) {
+		wlr_log(WLR_ERROR, "Failed to wait for render timeline: eventfd error");
+	}
+
+	if (mask & WL_EVENT_READABLE) {
+		uint64_t ev_fd_value;
+		if (read(ev_fd, &ev_fd_value, sizeof(ev_fd_value)) <= 0) {
+			wlr_log(WLR_ERROR, "Failed to wait for render timeline: read() failed");
+		}
+	}
+
+	close(ev_fd);
+	waiter->func(waiter->data);
+	free(waiter);
+	return 0;
+}
+
+struct wl_event_source *wlr_render_timeline_wait(struct wlr_render_timeline *timeline,
+		uint64_t point, uint32_t flags, struct wl_event_loop *loop,
+		wlr_render_timeline_wait_func_t func, void *data) {
+	uint32_t signaled_point;
+	int ret = drmSyncobjTimelineWait(timeline->drm_fd, &timeline->handle, &point, 1, 0, flags, &signaled_point);
+	if (ret == 0) {
+		func(data);
+		return NULL;
+	} else if (ret != -ETIME) {
+		wlr_log_errno(WLR_ERROR, "drmSyncobjWait() failed");
+		return NULL;
+	}
+
+	int ev_fd;
+#if HAVE_EVENTFD
+	ev_fd = eventfd(0, EFD_CLOEXEC);
+	if (ev_fd < 0) {
+		wlr_log_errno(WLR_ERROR, "eventfd() failed");
+	}
+#else
+	ev_fd = -1;
+	wlr_log(WLR_ERROR, "eventfd() is unavailable");
+#endif
+	if (ev_fd < 0) {
+		return NULL;
+	}
+
+	struct drm_syncobj_eventfd syncobj_eventfd = {
+		.handle = timeline->handle,
+		.flags = flags,
+		.point = point,
+		.fd = ev_fd,
+	};
+	if (drmIoctl(timeline->drm_fd, DRM_IOCTL_SYNCOBJ_EVENTFD, &syncobj_eventfd) != 0) {
+		wlr_log_errno(WLR_ERROR, "DRM_IOCTL_SYNCOBJ_EVENTFD failed");
+		close(ev_fd);
+		return NULL;
+	}
+
+	struct wlr_render_timeline_waiter *waiter = calloc(1, sizeof(*waiter));
+	if (waiter == NULL) {
+		wlr_log(WLR_ERROR, "Allocation failed");
+		close(ev_fd);
+		return NULL;
+	}
+
+	waiter->func = func;
+	waiter->data = data;
+
+	return wl_event_loop_add_fd(loop, ev_fd, WL_EVENT_READABLE, handle_eventfd_ready, waiter);
+}
-- 
GitLab


From 6883feaa29864925a434cdf312c680e09b62be55 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Thu, 21 Oct 2021 15:02:31 +0200
Subject: [PATCH 13/14] linux-drm-syncobj-v1: new protocol implementation

References: https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/90
---
 include/wlr/types/wlr_linux_drm_syncobj_v1.h |  50 +++
 protocol/meson.build                         |   1 +
 types/meson.build                            |   1 +
 types/wlr_linux_drm_syncobj_v1.c             | 399 +++++++++++++++++++
 4 files changed, 451 insertions(+)
 create mode 100644 include/wlr/types/wlr_linux_drm_syncobj_v1.h
 create mode 100644 types/wlr_linux_drm_syncobj_v1.c

diff --git a/include/wlr/types/wlr_linux_drm_syncobj_v1.h b/include/wlr/types/wlr_linux_drm_syncobj_v1.h
new file mode 100644
index 0000000000..0875f7dba9
--- /dev/null
+++ b/include/wlr/types/wlr_linux_drm_syncobj_v1.h
@@ -0,0 +1,50 @@
+/*
+ * This an unstable interface of wlroots. No guarantees are made regarding the
+ * future consistency of this API.
+ */
+#ifndef WLR_USE_UNSTABLE
+#error "Add -DWLR_USE_UNSTABLE to enable unstable wlroots features"
+#endif
+
+#ifndef WLR_TYPES_WLR_LINUX_DRM_SYNCOBJ_V1_H
+#define WLR_TYPES_WLR_LINUX_DRM_SYNCOBJ_V1_H
+
+#include <wayland-server-core.h>
+#include <wlr/util/addon.h>
+
+struct wlr_linux_drm_syncobj_surface_v1_state {
+	struct wlr_render_timeline *acquire_timeline;
+	uint64_t acquire_point;
+
+	struct wlr_render_timeline *release_timeline;
+	uint64_t release_point;
+};
+
+struct wlr_linux_drm_syncobj_manager_v1 {
+	struct wl_global *global;
+
+	struct {
+		struct wl_signal destroy;
+	} events;
+
+	// private state
+
+	int drm_fd;
+
+	struct wl_listener display_destroy;
+};
+
+/**
+ * Advertise explicit synchronization support to clients.
+ *
+ * The compositor must be prepared to handle fences coming from clients and to
+ * send release fences correctly. In particular, both the renderer and the
+ * backend need to support explicit synchronization.
+ */
+struct wlr_linux_drm_syncobj_manager_v1 *wlr_linux_drm_syncobj_manager_v1_create(
+	struct wl_display *display, uint32_t version, int drm_fd);
+
+struct wlr_linux_drm_syncobj_surface_v1_state *wlr_linux_drm_syncobj_v1_get_surface_state(
+	struct wlr_linux_drm_syncobj_manager_v1 *manager, struct wlr_surface *surface);
+
+#endif
diff --git a/protocol/meson.build b/protocol/meson.build
index e63b4aeffb..64463ea3c0 100644
--- a/protocol/meson.build
+++ b/protocol/meson.build
@@ -26,6 +26,7 @@ protocols = {
 	'ext-idle-notify-v1': wl_protocol_dir / 'staging/ext-idle-notify/ext-idle-notify-v1.xml',
 	'ext-session-lock-v1': wl_protocol_dir / 'staging/ext-session-lock/ext-session-lock-v1.xml',
 	'fractional-scale-v1': wl_protocol_dir / 'staging/fractional-scale/fractional-scale-v1.xml',
+	'linux-drm-syncobj-v1': wl_protocol_dir / 'staging/linux-drm-syncobj/linux-drm-syncobj-v1.xml',
 	'security-context-v1': wl_protocol_dir / 'staging/security-context/security-context-v1.xml',
 	'single-pixel-buffer-v1': wl_protocol_dir / 'staging/single-pixel-buffer/single-pixel-buffer-v1.xml',
 	'xdg-activation-v1': wl_protocol_dir / 'staging/xdg-activation/xdg-activation-v1.xml',
diff --git a/types/meson.build b/types/meson.build
index 0ab0ee0feb..958c29c702 100644
--- a/types/meson.build
+++ b/types/meson.build
@@ -54,6 +54,7 @@ wlr_files += files(
 	'wlr_keyboard_shortcuts_inhibit_v1.c',
 	'wlr_layer_shell_v1.c',
 	'wlr_linux_dmabuf_v1.c',
+	'wlr_linux_drm_syncobj_v1.c',
 	'wlr_linux_explicit_synchronization_v1.c',
 	'wlr_matrix.c',
 	'wlr_output_layer.c',
diff --git a/types/wlr_linux_drm_syncobj_v1.c b/types/wlr_linux_drm_syncobj_v1.c
new file mode 100644
index 0000000000..7a62a04ead
--- /dev/null
+++ b/types/wlr_linux_drm_syncobj_v1.c
@@ -0,0 +1,399 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <wlr/render/timeline.h>
+#include <wlr/types/wlr_compositor.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
+#include <xf86drm.h>
+#include "linux-drm-syncobj-v1-protocol.h"
+
+#define LINUX_DRM_SYNCOBJ_V1_VERSION 1
+
+struct wlr_linux_drm_syncobj_surface_v1 {
+	struct wl_resource *resource;
+	struct wlr_surface *surface;
+	struct wlr_linux_drm_syncobj_surface_v1_state pending, current;
+
+	struct wlr_addon addon;
+	struct wlr_surface_synced synced;
+
+	struct wl_listener client_commit;
+};
+
+struct wlr_linux_drm_syncobj_surface_v1_commit {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface;
+	uint32_t cached_seq;
+};
+
+static const struct wp_linux_drm_syncobj_manager_v1_interface manager_impl;
+static const struct wp_linux_drm_syncobj_timeline_v1_interface timeline_impl;
+static const struct wp_linux_drm_syncobj_surface_v1_interface surface_impl;
+
+static struct wlr_linux_drm_syncobj_manager_v1 *manager_from_resource(
+		struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&wp_linux_drm_syncobj_manager_v1_interface, &manager_impl));
+	return wl_resource_get_user_data(resource);
+}
+
+static struct wlr_render_timeline *timeline_from_resource(
+		struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&wp_linux_drm_syncobj_timeline_v1_interface, &timeline_impl));
+	return wl_resource_get_user_data(resource);
+}
+
+// Returns NULL if the syncobj surface is inert
+static struct wlr_linux_drm_syncobj_surface_v1 *surface_from_resource(
+		struct wl_resource *resource) {
+	assert(wl_resource_instance_of(resource,
+		&wp_linux_drm_syncobj_surface_v1_interface, &surface_impl));
+	return wl_resource_get_user_data(resource);
+}
+
+static void timeline_handle_resource_destroy(struct wl_resource *resource) {
+	struct wlr_render_timeline *timeline = timeline_from_resource(resource);
+	wlr_render_timeline_unref(timeline);
+}
+
+static void timeline_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static const struct wp_linux_drm_syncobj_timeline_v1_interface timeline_impl = {
+	.destroy = timeline_handle_destroy,
+};
+
+static void surface_destroy(struct wlr_linux_drm_syncobj_surface_v1 *surface) {
+	if (surface == NULL) {
+		return;
+	}
+	wl_list_remove(&surface->client_commit.link);
+	wlr_addon_finish(&surface->addon);
+	wlr_surface_synced_finish(&surface->synced);
+	wl_resource_set_user_data(surface->resource, NULL);
+	free(surface);
+}
+
+static void surface_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static void surface_handle_set_acquire_point(struct wl_client *client,
+		struct wl_resource *resource, struct wl_resource *timeline_resource,
+		uint32_t point_hi, uint32_t point_lo) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		surface_from_resource(resource);
+	if (surface == NULL) {
+		wl_resource_post_error(resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_SURFACE,
+			"The surface has been destroyed");
+		return;
+	}
+
+	struct wlr_render_timeline *timeline =
+		timeline_from_resource(timeline_resource);
+	uint64_t point = (uint64_t)point_hi << 32 | point_lo;
+
+	wlr_render_timeline_unref(surface->pending.acquire_timeline);
+	surface->pending.acquire_timeline = wlr_render_timeline_ref(timeline);
+	surface->pending.acquire_point = point;
+}
+
+static void surface_handle_set_release_point(struct wl_client *client,
+		struct wl_resource *resource, struct wl_resource *timeline_resource,
+		uint32_t point_hi, uint32_t point_lo) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		surface_from_resource(resource);
+	if (surface == NULL) {
+		wl_resource_post_error(resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_SURFACE,
+			"The surface has been destroyed");
+		return;
+	}
+
+	struct wlr_render_timeline *timeline =
+		timeline_from_resource(timeline_resource);
+	uint64_t point = (uint64_t)point_hi << 32 | point_lo;
+
+	wlr_render_timeline_unref(surface->pending.release_timeline);
+	surface->pending.release_timeline = wlr_render_timeline_ref(timeline);
+	surface->pending.release_point = point;
+}
+
+static const struct wp_linux_drm_syncobj_surface_v1_interface surface_impl = {
+	.destroy = surface_handle_destroy,
+	.set_acquire_point = surface_handle_set_acquire_point,
+	.set_release_point = surface_handle_set_release_point,
+};
+
+static void surface_handle_resource_destroy(struct wl_resource *resource) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		surface_from_resource(resource);
+	surface_destroy(surface);
+}
+
+static void surface_addon_handle_surface_destroy(struct wlr_addon *addon) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		wl_container_of(addon, surface, addon);
+	surface_destroy(surface);
+}
+
+static const struct wlr_addon_interface surface_addon_impl = {
+	.name = "wp_linux_drm_syncobj_surface_v1",
+	.destroy = surface_addon_handle_surface_destroy,
+};
+
+static void surface_synced_finish_state(void *_state) {
+	struct wlr_linux_drm_syncobj_surface_v1_state *state = _state;
+	wlr_render_timeline_unref(state->acquire_timeline);
+	wlr_render_timeline_unref(state->release_timeline);
+}
+
+static void surface_synced_move_state(void *_dst, void *_src) {
+	struct wlr_linux_drm_syncobj_surface_v1_state *dst = _dst, *src = _src;
+	// TODO: immediately signal dst.release_timeline if necessary
+	surface_synced_finish_state(dst);
+	*dst = *src;
+	*src = (struct wlr_linux_drm_syncobj_surface_v1_state){0};
+}
+
+static const struct wlr_surface_synced_impl surface_synced_impl = {
+	.state_size = sizeof(struct wlr_linux_drm_syncobj_surface_v1_state),
+	.finish_state = surface_synced_finish_state,
+	.move_state = surface_synced_move_state,
+};
+
+static void manager_handle_destroy(struct wl_client *client,
+		struct wl_resource *resource) {
+	wl_resource_destroy(resource);
+}
+
+static struct wlr_linux_drm_syncobj_surface_v1 *surface_from_wlr_surface(
+		struct wlr_linux_drm_syncobj_manager_v1 *manager,
+		struct wlr_surface *wlr_surface) {
+	struct wlr_addon *addon =
+		wlr_addon_find(&wlr_surface->addons, manager, &surface_addon_impl);
+	if (addon == NULL) {
+		return NULL;
+	}
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		wl_container_of(addon, surface, addon);
+	return surface;
+}
+
+static void surface_commit_handle_fence_available(void *data) {
+	struct wlr_linux_drm_syncobj_surface_v1_commit *commit = data;
+	wlr_surface_unlock_cached(commit->surface->surface, commit->cached_seq);
+	free(commit);
+}
+
+static void surface_handle_client_commit(struct wl_listener *listener,
+		void *data) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		wl_container_of(listener, surface, client_commit);
+
+	if (surface->pending.acquire_timeline != NULL &&
+			surface->surface->pending.buffer == NULL) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_BUFFER,
+			"Acquire point set but no buffer attached");
+		return;
+	}
+	if (surface->pending.release_timeline != NULL &&
+			surface->surface->pending.buffer == NULL) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_BUFFER,
+			"Release point set but no buffer attached");
+		return;
+	}
+
+	if (surface->pending.acquire_timeline == NULL &&
+			surface->surface->pending.buffer != NULL) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_ACQUIRE_POINT,
+			"Buffer attached but no acquire point set");
+		return;
+	}
+	if (surface->pending.release_timeline == NULL &&
+			surface->surface->pending.buffer != NULL) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_NO_RELEASE_POINT,
+			"Buffer attached but no release point set");
+		return;
+	}
+
+	if (surface->pending.acquire_timeline != NULL &&
+			surface->pending.release_timeline != NULL &&
+			surface->pending.acquire_timeline == surface->pending.release_timeline &&
+			surface->pending.acquire_point == surface->pending.release_point) {
+		wl_resource_post_error(surface->resource,
+			WP_LINUX_DRM_SYNCOBJ_SURFACE_V1_ERROR_CONFLICTING_POINTS,
+			"Acquire and release points conflict");
+		return;
+	}
+
+	// Block the surface commit until the fence materializes
+	// TODO: unregister on surface destroy
+	struct wlr_linux_drm_syncobj_surface_v1_commit *commit = calloc(1, sizeof(*commit));
+	if (commit == NULL) {
+		wl_resource_post_no_memory(surface->resource);
+		return;
+	}
+
+	commit->surface = surface;
+	commit->cached_seq = wlr_surface_lock_pending(surface->surface);
+
+	// TODO: this leaks the event source
+	struct wl_client *client = wl_resource_get_client(surface->resource);
+	struct wl_display *display = wl_client_get_display(client);
+	struct wl_event_loop *loop = wl_display_get_event_loop(display);
+	wlr_render_timeline_wait(surface->pending.acquire_timeline, surface->pending.acquire_point,
+		DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE, loop,
+		surface_commit_handle_fence_available, commit);
+}
+
+static void manager_handle_get_surface(struct wl_client *client,
+		struct wl_resource *resource, uint32_t id,
+		struct wl_resource *surface_resource) {
+	struct wlr_linux_drm_syncobj_manager_v1 *manager =
+		manager_from_resource(resource);
+	struct wlr_surface *wlr_surface = wlr_surface_from_resource(surface_resource);
+
+	if (surface_from_wlr_surface(manager, wlr_surface) != NULL) {
+		wl_resource_post_error(resource,
+			WP_LINUX_DRM_SYNCOBJ_MANAGER_V1_ERROR_SURFACE_EXISTS,
+			"wp_linux_drm_syncobj_surface_v1 already created for this surface");
+		return;
+	}
+
+	struct wlr_linux_drm_syncobj_surface_v1 *surface = calloc(1, sizeof(*surface));
+	if (surface == NULL) {
+		wl_resource_post_no_memory(resource);
+		return;
+	}
+
+	if (!wlr_surface_synced_init(&surface->synced, wlr_surface,
+			&surface_synced_impl, &surface->pending, &surface->current)) {
+		goto error_surface;
+	}
+
+	uint32_t version = wl_resource_get_version(resource);
+	surface->resource = wl_resource_create(client,
+		&wp_linux_drm_syncobj_surface_v1_interface, version, id);
+	if (surface->resource == NULL) {
+		goto error_surface_synced;
+	}
+	wl_resource_set_implementation(surface->resource,
+		&surface_impl, surface, surface_handle_resource_destroy);
+
+	surface->surface = wlr_surface;
+
+	surface->client_commit.notify = surface_handle_client_commit;
+	wl_signal_add(&wlr_surface->events.client_commit, &surface->client_commit);
+
+	wlr_addon_init(&surface->addon, &wlr_surface->addons, manager,
+		&surface_addon_impl);
+
+	return;
+
+error_surface_synced:
+	wlr_surface_synced_finish(&surface->synced);
+error_surface:
+	free(surface);
+	wl_resource_post_no_memory(resource);
+}
+
+static void manager_handle_import_timeline(struct wl_client *client,
+		struct wl_resource *resource, uint32_t id, int drm_syncobj_fd) {
+	struct wlr_linux_drm_syncobj_manager_v1 *manager =
+		manager_from_resource(resource);
+
+	struct wlr_render_timeline *timeline =
+		wlr_render_timeline_import(manager->drm_fd, drm_syncobj_fd);
+	close(drm_syncobj_fd);
+	if (timeline == NULL) {
+		wl_resource_post_error(resource,
+			WP_LINUX_DRM_SYNCOBJ_MANAGER_V1_ERROR_INVALID_TIMELINE,
+			"Failed to import drm_syncobj timeline");
+		return;
+	}
+
+	uint32_t version = wl_resource_get_version(resource);
+	struct wl_resource *timeline_resource = wl_resource_create(client,
+		&wp_linux_drm_syncobj_timeline_v1_interface, version, id);
+	if (timeline_resource == NULL) {
+		wl_resource_post_no_memory(resource);
+		return;
+	}
+	wl_resource_set_implementation(timeline_resource,
+		&timeline_impl, timeline, timeline_handle_resource_destroy);
+}
+
+static const struct wp_linux_drm_syncobj_manager_v1_interface manager_impl = {
+	.destroy = manager_handle_destroy,
+	.get_surface = manager_handle_get_surface,
+	.import_timeline = manager_handle_import_timeline,
+};
+
+static void manager_bind(struct wl_client *client, void *data,
+		uint32_t version, uint32_t id) {
+	struct wlr_linux_drm_syncobj_manager_v1 *manager = data;
+
+	struct wl_resource *resource = wl_resource_create(client,
+		&wp_linux_drm_syncobj_manager_v1_interface, version, id);
+	if (resource == NULL) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+	wl_resource_set_implementation(resource, &manager_impl, manager, NULL);
+}
+
+static void handle_display_destroy(struct wl_listener *listener, void *data) {
+	struct wlr_linux_drm_syncobj_manager_v1 *manager =
+		wl_container_of(listener, manager, display_destroy);
+	wl_signal_emit_mutable(&manager->events.destroy, NULL);
+	wl_list_remove(&manager->display_destroy.link);
+	wl_global_destroy(manager->global);
+	free(manager);
+}
+
+struct wlr_linux_drm_syncobj_manager_v1 *wlr_linux_drm_syncobj_manager_v1_create(
+		struct wl_display *display, uint32_t version, int drm_fd) {
+	struct wlr_linux_drm_syncobj_manager_v1 *manager = calloc(1, sizeof(*manager));
+	if (manager == NULL) {
+		return NULL;
+	}
+
+	// TODO: maybe dup drm_fd here?
+	manager->drm_fd = drm_fd;
+	wl_signal_init(&manager->events.destroy);
+
+	manager->global = wl_global_create(display,
+		&wp_linux_drm_syncobj_manager_v1_interface,
+		LINUX_DRM_SYNCOBJ_V1_VERSION, manager, manager_bind);
+	if (manager->global == NULL) {
+		free(manager);
+		return NULL;
+	}
+
+	manager->display_destroy.notify = handle_display_destroy;
+	wl_display_add_destroy_listener(display, &manager->display_destroy);
+
+	return manager;
+}
+
+struct wlr_linux_drm_syncobj_surface_v1_state *
+wlr_linux_drm_syncobj_v1_get_surface_state(
+		struct wlr_linux_drm_syncobj_manager_v1 *manager,
+		struct wlr_surface *wlr_surface) {
+	struct wlr_linux_drm_syncobj_surface_v1 *surface =
+		surface_from_wlr_surface(manager, wlr_surface);
+	if (surface == NULL) {
+		return NULL;
+	}
+	return &surface->current;
+}
-- 
GitLab


From 23ca41b359bcf86c369d255cbe3730b96b569f83 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Thu, 21 Oct 2021 15:23:38 +0200
Subject: [PATCH 14/14] examples/explicit-sync: support linux-drm-syncobj-v1

---
 examples/explicit-sync.c | 49 +++++++++++++++++++++++++++++++++-------
 1 file changed, 41 insertions(+), 8 deletions(-)

diff --git a/examples/explicit-sync.c b/examples/explicit-sync.c
index 22c10df841..d32fa45d74 100644
--- a/examples/explicit-sync.c
+++ b/examples/explicit-sync.c
@@ -12,6 +12,7 @@
 #include <wlr/render/timeline.h>
 #include <wlr/render/wlr_renderer.h>
 #include <wlr/types/wlr_compositor.h>
+#include <wlr/types/wlr_linux_drm_syncobj_v1.h>
 #include <wlr/types/wlr_linux_explicit_synchronization_v1.h>
 #include <wlr/types/wlr_output.h>
 #include <wlr/types/wlr_xdg_shell.h>
@@ -28,6 +29,7 @@ struct server {
 	struct wlr_allocator *allocator;
 	struct wlr_renderer *renderer;
 	struct wlr_linux_explicit_synchronization_v1 *explicit_sync_v1;
+	struct wlr_linux_drm_syncobj_manager_v1 *drm_syncobj_manager_v1;
 
 	struct wl_list outputs;
 	struct wl_list surfaces;
@@ -86,19 +88,35 @@ static void output_handle_frame(struct wl_listener *listener, void *data) {
 			continue;
 		}
 
-		uint64_t surface_point = surface->wlr->current.seq;
-		if (!wlr_linux_explicit_synchronization_v1_signal_surface_timeline(
-				output->server->explicit_sync_v1, surface->wlr,
-				surface->timeline, surface_point)) {
-			wlr_log(WLR_ERROR, "Failed to signal surface timeline");
-			continue;
+		struct wlr_render_timeline *wait_timeline = NULL;
+		uint64_t wait_point = 0;
+		struct wlr_linux_drm_syncobj_surface_v1_state *sync_v2_state =
+			wlr_linux_drm_syncobj_v1_get_surface_state(
+			output->server->drm_syncobj_manager_v1, surface->wlr);
+		if (sync_v2_state != NULL) {
+			if (sync_v2_state->acquire_timeline == NULL) {
+				wlr_log(WLR_ERROR, "Missing acquire sync point");
+				continue;
+			}
+			wait_timeline = sync_v2_state->acquire_timeline;
+			wait_point = sync_v2_state->acquire_point;
+		} else {
+			uint64_t surface_point = surface->wlr->current.seq;
+			if (!wlr_linux_explicit_synchronization_v1_signal_surface_timeline(
+					output->server->explicit_sync_v1, surface->wlr,
+					surface->timeline, surface_point)) {
+				wlr_log(WLR_ERROR, "Failed to signal surface timeline");
+				continue;
+			}
+			wait_timeline = surface->timeline;
+			wait_point = surface_point;
 		}
 
 		wlr_render_pass_add_texture(pass, &(struct wlr_render_texture_options){
 			.texture = texture,
 			.dst_box = { .x = pos, .y = pos },
-			.wait_timeline = surface->timeline,
-			.wait_point = surface_point,
+			.wait_timeline = wait_timeline,
+			.wait_point = wait_point,
 		});
 
 		wlr_surface_send_frame_done(surface->wlr, &now);
@@ -116,6 +134,17 @@ static void output_handle_frame(struct wl_listener *listener, void *data) {
 	wlr_output_state_finish(&state);
 
 	wl_list_for_each(surface, &output->server->surfaces, link) {
+		struct wlr_linux_drm_syncobj_surface_v1_state *sync_v2_state =
+			wlr_linux_drm_syncobj_v1_get_surface_state(
+			output->server->drm_syncobj_manager_v1, surface->wlr);
+		if (sync_v2_state != NULL && sync_v2_state->release_timeline != NULL) {
+			if (!wlr_render_timeline_transfer(sync_v2_state->release_timeline,
+					sync_v2_state->release_point, output->out_timeline,
+					output_point)) {
+				wlr_log(WLR_ERROR, "Failed to transfer surface release timeline");
+			}
+		}
+
 		if (!wlr_linux_explicit_synchronization_v1_wait_surface_timeline(
 				output->server->explicit_sync_v1, surface->wlr,
 				output->out_timeline, output_point)) {
@@ -221,6 +250,10 @@ int main(int argc, char *argv[]) {
 
 	server.explicit_sync_v1 = wlr_linux_explicit_synchronization_v1_create(server.display);
 
+	int drm_fd = wlr_renderer_get_drm_fd(server.renderer);
+	server.drm_syncobj_manager_v1 =
+		wlr_linux_drm_syncobj_manager_v1_create(server.display, 1, drm_fd);
+
 	wl_list_init(&server.outputs);
 	wl_list_init(&server.surfaces);
 
-- 
GitLab

